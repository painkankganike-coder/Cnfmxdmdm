local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

local Window = WindUI:CreateWindow({
    Title = "Kaiju Hub | Pvp Paid ðŸ’µ",
    Icon = "gitlab",
    Author = "My Kaiju | BlockSpinðŸ”«",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "v0.2.8",
    Icon = "cloud",
    Color = Color3.fromHex("#2889F7"),
    Radius = 13,
})

local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})
local CheaterTab = Window:Tab({Title = "CHEATER:", Icon = "user"})
CheaterTab:Section({Title="CHEATER :"})
local MiscTab = Window:Tab({Title = "MISC:", Icon = "warehouse"})
MiscTab:Section({Title="Misc :"})
local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})
local WeaponTab = Window:Tab({Title = "Weapon Mods:", Icon = "crosshair"})
WeaponTab:Section({Title="Weapon Mods :"})
local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="Server Hop  :"})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Config
local BOX_COLOR_DEFAULT = Color3.fromRGB(255, 255, 255)
local BOX_COLOR_LOCKED = Color3.fromRGB(255, 0, 0)
local BOX_THICKNESS = 2
local SCALE_MULTIPLIER = 1

-- Table à¹€à¸à¹‡à¸š ESP à¹à¸•à¹ˆà¸¥à¸°à¸„à¸™
local espPlayers = {}

-- à¸•à¸±à¸§à¹à¸›à¸£ CurrentTarget (à¸•à¸²à¸¡ tracerLine)
local CurrentTarget = nil

-- à¹à¸›à¸¥à¸‡à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¹‚à¸¥à¸à¹€à¸›à¹‡à¸™à¸«à¸™à¹‰à¸²à¸ˆà¸­
local function worldToViewport(pos)
    local screen, onScreen = Camera:WorldToViewportPoint(pos)
    return Vector2.new(screen.X, screen.Y), onScreen
end

-- à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™ Box ESP
local function createLines(color)
    local lines = {}
    for i=1,12 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = color
        line.Thickness = BOX_THICKNESS
        line.Transparency = 1
        lines[i] = line
    end
    return lines
end

-- à¸ªà¸£à¹‰à¸²à¸‡ ESP à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™
local function createBoxESP(plr)
    if espPlayers[plr] or plr == LocalPlayer then return end

    local lines = createLines(BOX_COLOR_DEFAULT)
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not _G.ESPEnabled then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        -- à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Character/HumanoidRootPart
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        local root = plr.Character.HumanoidRootPart
        local rootPos = root.Position
        local scale = root.Size.Y * SCALE_MULTIPLIER

        local corners = {
            Vector3.new(-1,  2, -1), Vector3.new( 1,  2, -1), Vector3.new( 1,  2,  1), Vector3.new(-1,  2,  1),
            Vector3.new(-1, -2, -1), Vector3.new( 1, -2, -1), Vector3.new( 1, -2,  1), Vector3.new(-1, -2,  1)
        }

        local screenCorners = {}
        local allOnScreen = true
        for i, offset in ipairs(corners) do
            local worldPos = rootPos + (root.CFrame:VectorToWorldSpace(offset * scale))
            local screenPos, onScreen = worldToViewport(worldPos)
            screenCorners[i] = screenPos
            if not onScreen then allOnScreen = false end
        end

        -- à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸­à¸¢à¸¹à¹ˆà¸šà¸™à¸«à¸™à¹‰à¸²à¸ˆà¸­ â†’ à¸‹à¹ˆà¸­à¸™à¹€à¸ªà¹‰à¸™
        if not allOnScreen then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        -- à¸­à¸±à¸›à¹€à¸”à¸•à¸ªà¸µà¸•à¸²à¸¡ CurrentTarget
        local targetColor = (CurrentTarget == plr) and BOX_COLOR_LOCKED or BOX_COLOR_DEFAULT
        if lines[1].Color ~= targetColor then
            for _, line in ipairs(lines) do line:Remove() end
            lines = createLines(targetColor)
            espPlayers[plr].lines = lines
        end

        -- à¸­à¸±à¸›à¹€à¸”à¸•à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¹€à¸ªà¹‰à¸™
        local edges = {
            {1,2},{2,3},{3,4},{4,1},
            {5,6},{6,7},{7,8},{8,5},
            {1,5},{2,6},{3,7},{4,8}
        }
        for i, edge in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[edge[1]]
            line.To = screenCorners[edge[2]]
            line.Visible = true
        end
    end)

    espPlayers[plr] = {connection = connection, lines = lines}
end

-- à¸¥à¸š ESP
local function removeBoxESP(plr)
    if espPlayers[plr] then
        if espPlayers[plr].connection then espPlayers[plr].connection:Disconnect() end
        for _, line in ipairs(espPlayers[plr].lines) do line:Remove() end
        espPlayers[plr] = nil
    end
end

-- à¹€à¸›à¸´à¸” ESP à¹ƒà¸«à¹‰à¸—à¸¸à¸à¸„à¸™
local function enableAllESP()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then createBoxESP(plr) end
    end
end

-- à¸›à¸´à¸” ESP
local function disableAllESP()
    for plr, _ in pairs(espPlayers) do
        removeBoxESP(plr)
    end
end

-- Player Added / Removing
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.1)
    if _G.ESPEnabled then createBoxESP(plr) end
end)
Players.PlayerRemoving:Connect(removeBoxESP)

EspTab:Toggle({
    Title = "Box",
    Default = false,
    Callback = function(state)
        _G.ESPEnabled = state
        if state then
            enableAllESP()
        else
            disableAllESP()
        end
    end
})


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer

local ItemESP_Enabled = false
local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

local RARITY_COLORS = {
    ["Common"] = Color3.fromRGB(230, 224, 224),
    ["Uncommon"] = Color3.fromRGB(200, 230, 200),
    ["Rare"] = Color3.fromRGB(160, 200, 255),
    ["Epic"] = Color3.fromRGB(200, 160, 255),
    ["Legendary"] = Color3.fromRGB(255, 200, 120),
    ["Omega"] = Color3.fromRGB(255, 120, 120),
}

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸£à¹‰à¸²à¸‡ key à¸‚à¸­à¸‡ Tool
local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id") or tool:GetAttribute("WeaponId") or tool:GetAttribute("GunId")
    if itemId and itemId ~= "" then
        return "ITEMID_" .. tostring(itemId)
    end

    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureId or "NOTEX"))
        elseif part:IsA("MeshPart") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureID or "NOTEX"))
        elseif part:IsA("Decal") and part.Texture and part.Texture ~= "" then
            table.insert(partsData, "DECAL_"..part.Texture)
        end
    end

    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end

    local displayName = tool:GetAttribute("DisplayName") or tool.Name
    local toolName = tool.Name
    local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"
    local imageId = tool:GetAttribute("ImageId") or "NOIMAGE"
    return "NAME_" .. displayName .. "_" .. toolName .. "_" .. rarity .. "_" .. imageId
end

-- à¸¥à¸‡à¸—à¸°à¹€à¸šà¸µà¸¢à¸™ Tool à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end

        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        if imageId and imageId ~= "" and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                pcall(function()
                    ContentProvider:PreloadAsync({imageId})
                end)
            end)
        end
    end
end

pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end
    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local key = generateUniqueKey(tool)
    return WeaponDB[key]
end

-- à¸ªà¸£à¹‰à¸²à¸‡ Billboard à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™
local function createBillboardForPlayer(player)
    if player == LocalPlayer then return end

    local function updateESP()
        if not ItemESP_Enabled or not player.Character then return end

        local currentTools = {}
        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") and tool.Name ~= "Fists" then
                    local info = getWeaponInfo(tool)
                    if info then
                        table.insert(currentTools, info)
                    end
                end
            end
        end

        scan(player.Character)
        local backpack = player:FindFirstChild("Backpack")
        if backpack then scan(backpack) end

        -- à¸–à¹‰à¸² Billboard à¸«à¸²à¸¢à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ à¸ªà¸£à¹‰à¸²à¸‡à¹ƒà¸«à¸¡à¹ˆ
        if not BillboardCache[player] or not BillboardCache[player].Parent then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ItemESP"
            billboard.Adornee = hrp
            billboard.Size = UDim2.new(0, 280, 0, 40)
            billboard.StudsOffset = Vector3.new(0, -6.5, 0)
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.Parent = hrp

            local container = Instance.new("Frame", billboard)
            container.Size = UDim2.new(1,0,1,0)
            container.BackgroundTransparency = 1

            BillboardCache[player] = billboard
        end

        -- à¸­à¸±à¸›à¹€à¸”à¸• Tool à¸ à¸²à¸¢à¹ƒà¸™ Billboard
        local container = BillboardCache[player]:FindFirstChildOfClass("Frame")
        if container then
            container:ClearAllChildren()
            local layout = Instance.new("UIGridLayout")
            layout.CellSize = UDim2.new(0,35,0,35)
            layout.CellPadding = UDim2.new(0,6,0,0)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            for i, info in ipairs(currentTools) do
                local img = Instance.new("ImageLabel")
                img.Parent = container
                img.Size = UDim2.new(0,35,0,35)
                img.BackgroundTransparency = 1
                img.Image = info.ImageId or "rbxassetid://7072725737"
                img.ScaleType = Enum.ScaleType.Fit
                img.LayoutOrder = i
                local color = RARITY_COLORS[info.Rarity] or Color3.fromRGB(255,255,255)
                img.ImageColor3 = color:Lerp(Color3.new(1,1,1),0.35)
            end
        end
    end

    -- à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸±à¸™à¸—à¸µà¸—à¸¸à¸ 1 à¸§à¸´à¸™à¸²à¸—à¸µ
    task.spawn(function()
        while ItemESP_Enabled and player.Parent do
            pcall(updateESP)
            task.wait(1)
        end
    end)

    -- à¹€à¸à¹‡à¸š connection
    ItemESP_UpdateConnections[player] = {}
    if player.Character then
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildAdded:Connect(function()
            if ItemESP_Enabled then task.defer(updateESP) end
        end))
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildRemoved:Connect(function()
            if ItemESP_Enabled then task.defer(updateESP) end
        end))
    end
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸¸à¸à¸„à¸™ (à¸ªà¸£à¹‰à¸²à¸‡ Billboard à¹ƒà¸«à¸¡à¹ˆà¸–à¹‰à¸²à¸«à¸²à¸¢)
local function UpdateAllItemESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local hasBillboard = BillboardCache[player] and BillboardCache[player].Parent
            if ItemESP_Enabled and (not hasBillboard) then
                createBillboardForPlayer(player)
            end
        end
    end
end

-- Loop à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸¸à¸ 1 à¸§à¸´à¸™à¸²à¸—à¸µ
task.spawn(function()
    while true do
        task.wait(1)
        UpdateAllItemESP()
    end
end)

-- Loop à¸ªà¸£à¹‰à¸²à¸‡/à¸£à¸µà¹€à¸Ÿà¸£à¸Š Billboard à¹ƒà¸«à¸¡à¹ˆà¸—à¸¸à¸ 20 à¸§à¸´à¸™à¸²à¸—à¸µ
task.spawn(function()
    while true do
        task.wait(20)
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and ItemESP_Enabled then
                if BillboardCache[player] and BillboardCache[player].Parent then
                    BillboardCache[player]:Destroy()
                    BillboardCache[player] = nil
                end
                createBillboardForPlayer(player)
            end
        end
    end
end)

-- Player Added/Removed
Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer and ItemESP_Enabled then
        task.wait(0.1)
        createBillboardForPlayer(p)
    end
end)
Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then
        BillboardCache[p]:Destroy()
        BillboardCache[p] = nil
    end
    if ItemESP_UpdateConnections[p] then
        for _, conn in pairs(ItemESP_UpdateConnections[p]) do
            if conn.Connected then conn:Disconnect() end
        end
        ItemESP_UpdateConnections[p] = nil
    end
end)

-- WindUI Toggle (à¸ªà¸¡à¸¡à¸•à¸´à¸§à¹ˆà¸² EspTab à¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§)
EspTab:Toggle({
    Title = "Item",
    Icon = "circle-check",
    Value = ItemESP_Enabled,
    Callback = function(state)
        ItemESP_Enabled = state
        if state then
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LocalPlayer then
                    createBillboardForPlayer(p)
                end
            end
        else
            for p, billboard in pairs(BillboardCache) do
                if billboard then billboard:Destroy() end
            end
            BillboardCache = {}
            for player, conns in pairs(ItemESP_UpdateConnections) do
                for _, conn in pairs(conns) do
                    if conn.Connected then conn:Disconnect() end
                end
                ItemESP_UpdateConnections[player] = nil
            end
        end
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local ItemESP_Enabled = false  -- à¸•à¸±à¸§à¹à¸›à¸£à¹€à¸›à¸´à¸”à¸›à¸´à¸” ESP
local ESP_Items = {}  -- à¹€à¸à¹‡à¸š Highlight + Drawing à¸‚à¸­à¸‡à¹à¸•à¹ˆà¸¥à¸°à¹„à¸­à¹€à¸—à¸¡

-- à¸ªà¸µà¸¡à¹ˆà¸§à¸‡à¸ªà¸§à¹ˆà¸²à¸‡à¹à¸šà¸šà¹€à¸—à¹ˆ à¹†
local HIGHLIGHT_COLOR = Color3.fromRGB(200, 0, 255)
local TEXT_COLOR = Color3.fromRGB(255, 255, 255)

-- à¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œà¸‚à¸­à¸‡à¸•à¸ (à¸£à¸­à¸‡à¸£à¸±à¸šà¸—à¸±à¹‰à¸‡ DroppedItem à¹à¸¥à¸° DroppedItems)
local droppedFolder = Workspace:FindFirstChild("DroppedItem") or Workspace:FindFirstChild("DroppedItems")
if not droppedFolder then
    warn("à¹„à¸¡à¹ˆà¸žà¸šà¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œ DroppedItem / DroppedItems")
    return
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸£à¹‰à¸²à¸‡ ESP à¹ƒà¸«à¹‰à¹„à¸­à¹€à¸—à¸¡ 1 à¸Šà¸´à¹‰à¸™
local function createItemESP(item)
    if not ItemESP_Enabled then return end
    if ESP_Items[item] then return end  -- à¸–à¹‰à¸²à¸¡à¸µà¹à¸¥à¹‰à¸§à¹„à¸¡à¹ˆà¸—à¸³à¸‹à¹‰à¸³
    if item.Name == "Money" then return end  -- à¸¢à¸à¹€à¸§à¹‰à¸™ Money
    if not item:FindFirstChild("Handle") and not item.PrimaryPart then return end

    local handle = item:FindFirstChild("Handle") or item.PrimaryPart

    -- Highlight à¸ªà¸µà¸¡à¹ˆà¸§à¸‡à¸ªà¸§à¹ˆà¸²à¸‡
    local highlight = Instance.new("Highlight")
    highlight.FillColor = HIGHLIGHT_COLOR
    highlight.OutlineColor = HIGHLIGHT_COLOR
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = item

    -- à¸Šà¸·à¹ˆà¸­à¹„à¸­à¹€à¸—à¸¡ (Drawing Text)
    local nameText = Drawing.new("Text")
    nameText.Size = 16
    nameText.Color = TEXT_COLOR
    nameText.Center = true
    nameText.Outline = true
    nameText.Font = 2
    nameText.Visible = true
    nameText.Text = item.Name

    -- à¸£à¸°à¸¢à¸°à¸—à¸²à¸‡ (Drawing Text)
    local distanceText = Drawing.new("Text")
    distanceText.Size = 10
    distanceText.Color = TEXT_COLOR
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Font = 2
    distanceText.Visible = true

    -- à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡
    ESP_Items[item] = {
        highlight = highlight,
        name = nameText,
        distance = distanceText,
        handle = handle
    }

    -- à¸¥à¸šà¹€à¸¡à¸·à¹ˆà¸­à¹„à¸­à¹€à¸—à¸¡à¸«à¸²à¸¢
    item.AncestryChanged:Connect(function()
        if not item.Parent then
            if ESP_Items[item] then
                highlight:Destroy()
                nameText:Remove()
                distanceText:Remove()
                ESP_Items[item] = nil
            end
        end
    end)
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸›à¸´à¸” ESP
local function enableItemESP()
    ItemESP_Enabled = true
    -- à¸ªà¹à¸à¸™à¸‚à¸­à¸‡à¹€à¸”à¸´à¸¡
    for _, item in pairs(droppedFolder:GetChildren()) do
        if item:IsA("Model") or item:IsA("Tool") or item:IsA("Folder") then
            task.spawn(function()
                task.wait(0.3)
                createItemESP(item)
            end)
        end
    end
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸›à¸´à¸” ESP
local function disableItemESP()
    ItemESP_Enabled = false
    for item, data in pairs(ESP_Items) do
        if data.highlight then data.highlight:Destroy() end
        if data.name then data.name:Remove() end
        if data.distance then data.distance:Remove() end
    end
    ESP_Items = {}
end

-- à¸­à¸±à¸›à¹€à¸”à¸•à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¸Šà¸·à¹ˆà¸­ + à¸£à¸°à¸¢à¸°à¸—à¸²à¸‡à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡
RunService.Heartbeat:Connect(function()
    if not ItemESP_Enabled then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local rootPos = player.Character.HumanoidRootPart.Position

    for item, data in pairs(ESP_Items) do
        if item and item.Parent and data.handle and data.handle.Parent then
            local worldPos = data.handle.Position + Vector3.new(0, 2, 0)
            local screenPos, onScreen = camera:WorldToViewportPoint(worldPos)

            if onScreen then
                local screen2D = Vector2.new(screenPos.X, screenPos.Y)
                local distance = math.floor((rootPos - data.handle.Position).Magnitude)

                data.name.Position = screen2D
                data.name.Visible = true

                data.distance.Position = screen2D + Vector2.new(0, 18)
                data.distance.Text = distance .. "m"
                data.distance.Visible = true
            else
                data.name.Visible = false
                data.distance.Visible = false
            end
        else
            -- à¸¥à¸šà¸–à¹‰à¸²à¹„à¸­à¹€à¸—à¸¡à¸«à¸²à¸¢
            if data.highlight then data.highlight:Destroy() end
            if data.name then data.name:Remove() end
            if data.distance then data.distance:Remove() end
            ESP_Items[item] = nil
        end
    end
end)

-- à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µà¸‚à¸­à¸‡à¸•à¸à¹ƒà¸«à¸¡à¹ˆ
droppedFolder.ChildAdded:Connect(function(item)
    task.wait(0.5)
    createItemESP(item)
end)

-- à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡ WindUI Toggle
EspTab:Toggle({
    Title = "Dropped Items",
    Value = ItemESP_Enabled,
    Callback = function(state)
        if state then
            enableItemESP()
        else
            disableItemESP()
        end
    end
})

-- à¸­à¸±à¸›à¹€à¸”à¸• CurrentTarget à¸•à¸²à¸¡ tracerLine à¸—à¸¸à¸ frame à¹à¸¥à¸°à¸‹à¸´à¸‡à¸„à¹Œ ESP à¹à¸šà¸š realtime
RunService.RenderStepped:Connect(function()
    -- à¹ƒà¸Šà¹‰ target à¸‚à¸­à¸‡ tracerLine / Silent Aim
    local target = GetClosestTarget() -- à¸ˆà¸²à¸à¹‚à¸„à¹‰à¸”à¸¥à¹‡à¸­à¸„à¹€à¸”à¸´à¸¡à¸‚à¸­à¸‡à¸„à¸¸à¸“
    CurrentTarget = target
end)

MiscTab:Keybind({
    Title = "Keybind",
    Value = "G",
    Callback = function(v)
        Window:SetToggleKey(Enum.KeyCode[v])
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- à¸«à¸² CounterTable à¸ˆà¸²à¸ getgc
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

-- Net.get Function
local Net = {}
local function NetGet(...)
    if not CounterTable or not CounterTable.func then
        warn("âŒ CounterTable à¹„à¸¡à¹ˆà¸žà¸š!")
        return
    end
    local args = {...}
    CounterTable.func = (CounterTable.func or 0) + 1
    local success, result = pcall(function()
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))
    end)
    if not success then
        warn("[NetGet Error]", result)
    end
    return result
end
function Net.get(...)
    return NetGet(...)
end

-- Claim All Function
local function ClaimAllQuests()
    local success, questFrame = pcall(function()
        return player:WaitForChild("PlayerGui"):WaitForChild("Quests"):WaitForChild("QuestsHolder"):WaitForChild("QuestsScrollingFrame")
    end)
    if not success or not questFrame then
        warn("âŒ Quest GUI à¹„à¸¡à¹ˆà¸žà¸š! (à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸›à¸´à¸” Quests)")
        return 0
    end
    
    local claimed = 0
    for _, child in ipairs(questFrame:GetChildren()) do
        if (child:IsA("Frame") or child:IsA("TextButton") or child:IsA("ImageButton")) and child.Name ~= "" then
            pcall(function()
                Net.get("claim_quest", child.Name)
            end)
            claimed = claimed + 1
            task.wait(0.2)
        end
    end
    return claimed
end

MiscTab:Button({
    Title = "Claim All Quests",
    Locked = false,
    Callback = function()
        local claimed = ClaimAllQuests()  -- à¹€à¸£à¸µà¸¢à¸à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ ClaimAllQuests
        if claimed > 0 then
            print("âœ… Claimed", claimed, "Quests!")
        else
            print("â„¹ï¸ à¹„à¸¡à¹ˆà¸¡à¸µ Quest à¹ƒà¸«à¹‰ Claim")
        end
    end
})

MiscTab:Code({
    Title = "My discord Server :",
    Code = [[ tiktok : KAIJN X HUB 
discord : https://discord.gg/j7tzEVZP67]]
})

local FireRateValue = Instance.new("NumberValue")
FireRateValue.Name = "FireRateValue"
FireRateValue.Value = 1200
FireRateValue.Parent = LocalPlayer

WeaponTab:Slider({
    Title = "Fire Rate",
    Step = 1,
    Value = {Min = 1, Max = 3000, Default = FireRateValue.Value},
    Callback = function(value)
        FireRateValue.Value = value
    end
})

-- à¹€à¸à¹‡à¸š Tool à¸—à¸µà¹ˆà¸­à¸±à¸›à¹€à¸”à¸•à¹à¸¥à¹‰à¸§
local updatedTools = {}

local function UpdateToolFireRate(tool)
    if not tool then return end
    if updatedTools[tool] then return end -- à¸–à¹‰à¸²à¹€à¸„à¸¢à¸­à¸±à¸›à¹€à¸”à¸•à¹à¸¥à¹‰à¸§à¹„à¸¡à¹ˆà¸ªà¹ˆà¸‡à¸‹à¹‰à¸³
    updatedTools[tool] = true

    for _, v in pairs(getgc(true)) do
        if typeof(v) == "table" and rawget(v, "states") then
            local s = v.states
            if s.instance == tool then
                if s.fire_rate and s.fire_rate.set then
                    s.fire_rate:set(FireRateValue.Value)
                    print("âœ… Fire Rate updated for Tool:", tool.Name)
                end
            end
        end
    end
end

-- à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š Tool à¹ƒà¸«à¸¡à¹ˆà¸•à¸­à¸™à¸–à¸·à¸­
LocalPlayer.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        UpdateToolFireRate(child)
    end
end)

-- à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Tool à¸—à¸µà¹ˆà¸–à¸·à¸­à¸­à¸¢à¸¹à¹ˆà¸•à¸­à¸™à¹‚à¸«à¸¥à¸”
task.spawn(function()
    local char = LocalPlayer.Character
    if char then
        for _, tool in pairs(char:GetChildren()) do
            if tool:IsA("Tool") then
                UpdateToolFireRate(tool)
            end
        end
    end
end)

-- No Recoil
local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)
getgenv().NoRecoilEnabled = false
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

local function EnableNoRecoil()
    if getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = true

    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
    end

    antiLoop = task.spawn(function()
        while getgenv().NoRecoilEnabled do
            local char = LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")
            if tool and tool:GetAttribute("Recoil") then
                tool:SetAttribute("Recoil", 0)
            end
            for _, gun in pairs(getgc(true)) do
                if typeof(gun) == "table" and rawget(gun, "instance") and gun.instance then
                    gun.instance:SetAttribute("Recoil", 0)
                end
            end
            task.wait(0.3)
        end
    end)
    print("âœ… No Recoil: ON")
end

local function DisableNoRecoil()
    if not getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = false
    GunModule.apply_recoil = original_recoil
    if antiLoop then
        task.cancel(antiLoop)
        antiLoop = nil
    end
    print("âŒ No Recoil: OFF")
end

function ToggleNoRecoil(state)
    if state then EnableNoRecoil() else DisableNoRecoil() end
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Value = false,
    Callback = function(state)
        ToggleNoRecoil(state)
    end
})

-- Hit Aura
WeaponTab:Section({Title="Auto Hit :"})
getgenv().HitAuraEnabled = false
local autoLoop = nil

local function getActiveTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then return obj end
    end
    return nil
end

local function getPlayersInRange(radius)
    local inRange = {}
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            local CounterTable
            pcall(function()
                for _, Obj in ipairs(getgc(true)) do
                    if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
                        CounterTable = Obj
                        break
                    end
                end
            end)
            local SendRemote
            pcall(function()
                local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
                SendRemote = Remotes:WaitForChild("Send", 5)
            end)
            if CounterTable and SendRemote then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "melee_attack", tool, {target}, lookAtCFrame, 0.75)
                end)
            end
        end
    end
end

local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

function ToggleHitAura(state)
    if state then
        getgenv().HitAuraEnabled = true
        StartHitAura()
        print("âœ… Hit Aura: ON")
    else
        StopHitAura()
        print("âŒ Hit Aura: OFF")
    end
end

WeaponTab:Toggle({
    Title = "Hit Aura",
    Default = false,
    Callback = function(state)
        ToggleHitAura(state)
    end
})

local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Value = false
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 150
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Value = 1000
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"
TargetPartValue.Parent = LocalPlayer

local AttackAntiLockEnabledValue = Instance.new("BoolValue")
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false
AttackAntiLockEnabledValue.Parent = LocalPlayer

local IgnorePlayers = {}
local CurrentTarget, head, aimPos
local hue = 0
local lastPositions = {}

local GunNames = {"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9","Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 1
tracerLine.Visible = false

local PREDICTION_FACTOR = 0.165
local PREDICTION_DISTANCE = 6

local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

local function AntiLockPrediction(part)
    if not part or not part.Parent then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    local humanoid = part.Parent:FindFirstChild("Humanoid")
    if not humanoid or not root then return part.Position end

    local headPos = part.Position + Vector3.new(0, (part:IsA("BasePart") and part.Size.Y or 1)/2, 0)

    if AttackAntiLockEnabledValue.Value then
        local velocity = root.Velocity
        local speed = velocity.Magnitude

        if speed >= 14 then
            local direction = velocity.Unit
            return headPos + direction * PREDICTION_DISTANCE
        else
            -- à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸‹à¹‰à¸²à¸¢à¸‚à¸§à¸²à¸«à¸™à¹‰à¸² à¸«à¸¥à¸±à¸‡
            local lastPos = lastPositions[part.Parent] or root.Position
            local movement = root.Position - lastPos
            lastPositions[part.Parent] = root.Position

            local direction = Vector3.new(0,0,0)
            if movement.Magnitude > 0.05 then
                direction = movement.Unit
            else
                direction = part.CFrame.LookVector
            end

            return headPos + direction * PREDICTION_DISTANCE
        end
    else
        return PredictPosition(part)
    end
end

local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = AntiLockPrediction(part)

            if MagicBulletValue.Value and (part and part.Parent and IsBehindWall(part)) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.05,0.05,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.fromHSV(math.random(),1,1)
            game:GetService("Debris"):AddItem(beam, 1)
        end
    end
    return oldFire(self, unpack(args))
end)

RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1)

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    CurrentTarget = target

    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromHSV(hue, 1, 1)
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

CombatTab:Toggle({
    Title = "Silent Aim",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
    end
})

CombatTab:Space()

CombatTab:Slider({
    Title = "FOV :",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value) FOVRadiusValue.Value = value end
})

CombatTab:Slider({
    Title = "Lock Distance :",
    Step = 25,
    Value = {Min = 50, Max = 3000, Default = LockDistanceValue.Value},
    Callback = function(value) LockDistanceValue.Value = value end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

CombatTab:Toggle({
    Title = "Magic Bullet",
    Value = MagicBulletValue.Value,
    Callback = function(state) MagicBulletValue.Value = state end
})

CombatTab:Input({
    Title = "Safe Players",
    Placeholder = "à¹ƒà¸ªà¹ˆà¸Šà¸·à¹ˆà¸­à¹€à¸žà¸·à¹ˆà¸­à¸™à¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸¥à¹‡à¸­à¸„, à¸„à¸±à¹ˆà¸™à¸”à¹‰à¸§à¸¢ ,",
    InputIcon = "shield-check",
    Callback = function(txt)
        IgnorePlayers = {}
        for inputName in string.gmatch(txt, '([^,]+)') do
            inputName = inputName:match("^%s*(.-)%s*$")
            table.insert(IgnorePlayers, inputName)
        end
    end
})


local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer
local placeId = game.PlaceId

ServerTab:Button({
    Title = "Copy JobId",
    Desc = "à¸„à¸±à¸”à¸¥à¸­à¸ID server",
    Callback = function()
        setclipboard(game.JobId)
        print("Copied JobId:", game.JobId)
    end
})

ServerTab:Divider()
local jobInput = ""
ServerTab:Input({
    Title = "JobId",
    Desc = "à¹ƒà¸ªà¹ˆ ID à¸—à¸µà¹ˆà¸ˆà¸°à¸¢à¹‰à¸²à¸¢à¹€à¸‚à¹‰à¸²",
    Placeholder = "",
    Callback = function(text)
        jobInput = text
    end
})

ServerTab:Button({
    Title = "Join JobId",
    Callback = function()
        if jobInput ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobInput, player)
        else
            warn("à¹ƒà¸ªà¹ˆ JobId à¹ƒà¸«à¹‰à¸–à¸¹à¸")
        end
    end
})

local PlaceId = 104715542330896
local TargetPlayers = 28

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = game.Players.LocalPlayer

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸”à¸¶à¸‡à¸£à¸²à¸¢à¸Šà¸·à¹ˆà¸­à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ
local function GetServers(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100%s"):format(
        PlaceId,
        cursor and ("&cursor=" .. cursor) or ""
    )

    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    return success and result or nil
end

-- â­ à¸›à¸¸à¹ˆà¸¡ WindUI à¹à¸šà¸š Button
ServerTab:Divider()
ServerTab:Section({Title="Auto Server Hop  :"})
ServerTab:Button({
    Title = "Auto big Server Hop",
    Desc = "à¸„à¹‰à¸™à¸«à¸²à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¸—à¸µà¹ˆà¸„à¸™ à¹€à¸¢à¸­à¸°à¹† " .. TargetPlayers,
    Callback = function()
        task.spawn(function()
            print("ðŸ” à¹€à¸£à¸´à¹ˆà¸¡à¸„à¹‰à¸™à¸«à¸²à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¸„à¸™ â‰¤ " .. TargetPlayers .. "...")

            while true do
                local cursor = nil
                local found = false

                repeat
                    local data = GetServers(cursor)
                    if not data then break end

                    for _, server in ipairs(data.data) do
                        local playing = server.playing or 0

                        if playing <= TargetPlayers and playing < server.maxPlayers then
                            print("ðŸ“Œ à¹€à¸ˆà¸­à¹€à¸‹à¸´à¸£à¹Œà¸Ÿ:", server.id, " | à¸„à¸™:", playing)
                            TeleportService:TeleportToPlaceInstance(PlaceId, server.id, LocalPlayer)
                            found = true
                            break
                        end
                    end

                    cursor = data.nextPageCursor
                until cursor == nil or found

                task.wait(0.2)
            end
        end)
    end
})

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

function Rejoin()
    local player = Players.LocalPlayer
    if not player then return end
    
    local placeId = game.PlaceId
    local jobId = game.JobId

    -- à¸–à¹‰à¸²à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸– rejoin à¹à¸šà¸šà¸à¸¥à¸±à¸šà¸«à¹‰à¸­à¸‡à¹€à¸”à¸´à¸¡à¹„à¸”à¹‰ à¸ˆà¸° teleport à¸›à¸à¸•à¸´à¹à¸—à¸™
    local success, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
    end)

    if not success then
        warn("Rejoin à¹à¸šà¸š instance à¹€à¸”à¸´à¸¡à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§:", err)
        TeleportService:Teleport(placeId, player)
    end
end

ServerTab:Button({
    Title = "Rejoin ",
    Desc = "à¹€à¸”à¹‡à¸à¸‚à¹‰à¸²à¸‡egg à¸­à¸¢à¸²à¸à¸à¸¥à¸±à¸šà¸šà¹‰à¸²à¸™",
    Callback = function()
        Rejoin()
    end
})

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local function GetServers(cursor)
    local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    if cursor then
        url = url .. "&cursor=" .. cursor
    end

    local success, response = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    if success then
        return response
    else
        warn("Error loading servers:", response)
        return nil
    end
end

function FindLowServer()
    local cursor = nil
    local lowestServer = nil

    repeat
        local servers = GetServers(cursor)
        if not servers then break end

        for _, server in ipairs(servers.data) do
            local playing = server.playing or 0

            if playing < server.maxPlayers then
                -- à¸«à¸²à¸„à¸™à¸™à¹‰à¸­à¸¢à¸—à¸µà¹ˆà¸ªà¸¸à¸”
                if (not lowestServer) or (playing < lowestServer.playing) then
                    lowestServer = server
                end
            end
        end

        cursor = servers.nextPageCursor
    until cursor == nil

    if lowestServer then
        print("ðŸ” à¸žà¸šà¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¸„à¸™à¸™à¸µà¹‰à¸™à¹‰à¸­à¸¢:", lowestServer.id, " à¸„à¸™:", lowestServer.playing)
        TeleportService:TeleportToPlaceInstance(game.PlaceId, lowestServer.id, Players.LocalPlayer)
    else
        warn("âŒ à¹„à¸¡à¹ˆà¸žà¸šà¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¸—à¸µà¹ˆà¸¡à¸µà¸Šà¹ˆà¸­à¸‡à¸§à¹ˆà¸²à¸‡")
    end
end

ServerTab:Button({
    Title = "small Server",
    Desc = "à¸«à¸²à¸„à¸™à¸™à¹‰à¸­à¸¢",
    Locked = false,
    Callback = function()
        FindLowServer()
    end
})

local FPSBoostEnabled = false

local Lighting = game:GetService("Lighting")
local OriginalSky = {}
local OriginalParts = {}

-- à¹‚à¸—à¸™à¹€à¸—à¸²à¹à¸šà¸šà¸ªà¸šà¸²à¸¢à¸•à¸²
local grayColor = Color3.fromRGB(180,180,180)

-- à¸šà¸±à¸™à¸—à¸¶à¸ Sky à¹€à¸”à¸´à¸¡
for _, v in ipairs(Lighting:GetChildren()) do
    if v:IsA("Sky") then
        table.insert(OriginalSky, v)
    end
end

-- à¸šà¸±à¸™à¸—à¸¶à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡ Part à¹€à¸”à¸´à¸¡
local function SaveOriginal(part)
    if OriginalParts[part] then return end
    OriginalParts[part] = {
        Color = part.Color,
        Material = part.Material,
        TextureID = part:IsA("MeshPart") and part.TextureID or nil
    }
end

local function BoostFPS_Enable()
    -- à¸¥à¸š Sky
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("Sky") then v:Destroy() end
    end

    -- à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ªà¸µ + à¸¥à¸šà¸ à¸²à¸ž
    for _, obj in ipairs(workspace:GetDescendants()) do

        if obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
            obj:Destroy()

        elseif obj:IsA("BasePart") then
            SaveOriginal(obj)
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic

        elseif obj:IsA("MeshPart") then
            SaveOriginal(obj)
            obj.TextureID = ""
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic
        end
    end
end

local function BoostFPS_Disable()
    -- à¸„à¸·à¸™ Sky
    for _, sky in ipairs(OriginalSky) do
        sky.Parent = Lighting
    end

    -- à¸„à¸·à¸™à¸„à¹ˆà¸²à¸‚à¸­à¸‡ Part à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
    for part, data in pairs(OriginalParts) do
        if part and part.Parent then
            part.Color = data.Color
            part.Material = data.Material
            if part:IsA("MeshPart") and data.TextureID then
                part.TextureID = data.TextureID
            end
        end
    end
end
ServerTab:Section({Title="Server Mods  :"})

ServerTab:Button({
    Title = "No sky  (Click)",
    Desc = "à¹€à¸›à¸´à¸”à¹€à¸žà¸·à¹ˆà¸­à¸ˆà¸°à¹€à¸‚à¹‰à¸²à¹‚à¸«à¸¡à¸”à¸«à¸™à¸²à¸§ à¹à¸¥à¸°à¹„à¸¡à¹ˆà¸¡à¸µà¸à¹‰à¸­à¸™à¹€à¸¡à¸†à¸•à¸¶à¸‡à¹†âšª",
    Callback = function()
        FPSBoostEnabled = not FPSBoostEnabled
        
        if FPSBoostEnabled then
            BoostFPS_Enable()
        else
            BoostFPS_Disable()
        end
    end
})

ServerTab:Button({
    Title = "Remove Roads",
    Desc = "à¸¥à¸šà¸–à¸™à¸™à¸­à¸­à¸ðŸ›£ï¸",
    Callback = function()

        local success, mapFolder = pcall(function()
            return workspace:WaitForChild("Map", 5)
        end)

        if not success or not mapFolder then
            warn("âŒ à¹„à¸¡à¹ˆà¸žà¸š workspace.Map")
            return
        end

        local road = mapFolder:FindFirstChild("RoadNetwork")
        if road then
            road:Destroy()
            print("âœ… à¸¥à¸š RoadNetwork à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§!")
        else
            warn("âŒ à¹„à¸¡à¹ˆà¸žà¸š Map.RoadNetwork")
        end
    end
})

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸¥à¸šà¸›à¸£à¸°à¸•à¸¹ DoorSystem à¹à¸¥à¸°à¸›à¸£à¸°à¸•à¸¹à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
local function removeDoors()
    pcall(function()
        -- à¸¥à¸šà¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œ DoorSystem
        if workspace:FindFirstChild("DoorSystem") then
            workspace.DoorSystem:Destroy()
        end

        -- à¸¥à¸¹à¸›à¸—à¸¸à¸à¸­à¹‡à¸­à¸šà¹€à¸ˆà¹‡à¸à¸•à¹Œà¹ƒà¸™ workspace
        for _, obj in pairs(workspace:GetDescendants()) do
            local name = obj.Name:lower()
            local parentName = obj.Parent and obj.Parent.Name:lower() or ""
            if name:find("door") or parentName:find("door") then
                if obj:IsA("Model") then
                    obj:Destroy()
                elseif obj:IsA("BasePart") then
                    obj.CanCollide = false
                    obj.Transparency = 1
                    if obj:FindFirstChild("ClickDetector") then
                        obj.ClickDetector.MaxActivationDistance = 0
                    end
                end
            end
        end
    end)
end

-- à¸ªà¸£à¹‰à¸²à¸‡à¸›à¸¸à¹ˆà¸¡ WindUI à¸ªà¸³à¸«à¸£à¸±à¸šà¸¥à¸šà¸›à¸£à¸°à¸•à¸¹
ServerTab:Button({
    Title = "Remove Doors",
    Desc = "à¸¥à¸šà¸›à¸£à¸°à¸•à¸¹à¸­à¸­à¸ðŸšª",
    Locked = false,
    Callback = function()
        removeDoors()  -- à¹€à¸£à¸µà¸¢à¸à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸¥à¸šà¸›à¸£à¸°à¸•à¸¹
        print("âœ… DoorSystem & all doors removed!")
    end
})
