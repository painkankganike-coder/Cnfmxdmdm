local SilentAimEnabledValue = Instance.new("BoolValue", LocalPlayer)
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false

local AttackAntiLockEnabledValue = Instance.new("BoolValue", LocalPlayer)
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false

local MagicBulletEnabledValue = Instance.new("BoolValue", LocalPlayer)
MagicBulletEnabledValue.Name = "MagicBulletEnabled"
MagicBulletEnabledValue.Value = false

local TargetPartValue = Instance.new("StringValue", LocalPlayer)
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"

local FOVRadiusValue = Instance.new("NumberValue", LocalPlayer)
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 230

local MaxLockDistanceValue = Instance.new("NumberValue", LocalPlayer)
MaxLockDistanceValue.Name = "MaxLockDistance"
MaxLockDistanceValue.Value = 1000

-- FireRate
local FireRateEnabled = Instance.new("BoolValue", LocalPlayer)
FireRateEnabled.Name = "FireRateEnabled"
FireRateEnabled.Value = false

local FireRateValue = Instance.new("NumberValue", LocalPlayer)
FireRateValue.Name = "FireRate"
FireRateValue.Value = 370

-- Aim Mode (Center Screen / Mouse)
local AimModeValue = Instance.new("StringValue", LocalPlayer)
AimModeValue.Name = "AimMode"
AimModeValue.Value = "Center"

local CurrentTarget
local head, aimPos
local IgnorePlayers = {}

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- 5Ô∏è‚É£ FOV Polygon (20 ‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°)
local sides = 20
local fovPolygon = {}
for i = 1, sides do
    fovPolygon[i] = Drawing.new("Line")
    fovPolygon[i].Color = Color3.fromRGB(0,255,0)
    fovPolygon[i].Thickness = 2
    fovPolygon[i].Visible = false
end

-- 6Ô∏è‚É£ Tracer Line
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.fromRGB(0,255,0)
tracerLine.Thickness = 3
tracerLine.Visible = false

-- 7Ô∏è‚É£ Prediction Factor
local PREDICTION_FACTOR_NORMAL = 0.165
local PREDICTION_FACTOR = PREDICTION_FACTOR_NORMAL
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")

-- 8Ô∏è‚É£ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center
    if AimModeValue.Value == "Center" then
        center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
        center = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(TargetPartValue.Value) then
            local skip = false
            for _, name in pairs(IgnorePlayers) do
                if player.Name == name then skip = true break end
            end
            if skip then continue end

            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character[TargetPartValue.Value].Position)
            if onScreen then
                local distToScreenCenter = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                local distToPlayer = (player.Character[TargetPartValue.Value].Position - LocalPlayer.Character.Head.Position).Magnitude
                if distToScreenCenter < FOVRadiusValue.Value and distToPlayer <= MaxLockDistanceValue.Value and distToScreenCenter < shortest then
                    shortest = distToScreenCenter
                    closest = player
                end
            end
        end
    end
    return closest
end

local function PredictPosition(part)
    if AttackAntiLockEnabledValue.Value then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return part.Position end
    local velocity = root.Velocity
    local prediction = part.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = part.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local function UpdateFireRate()
    if not FireRateEnabled.Value then return end
    local char = LocalPlayer.Character
    if not char then return end
    for _, tool in pairs(char:GetChildren()) do
        if tool:IsA("Tool") and GunLookup[tool.Name] then
            for _, val in pairs(tool:GetChildren()) do
                if val:IsA("NumberValue") and val.Name:lower():find("fire") then
                    val.Value = FireRateValue.Value
                end
            end
            if tool:FindFirstChild("FireRate") then
                tool.FireRate.Value = FireRateValue.Value
            end
        end
    end
end

LocalPlayer.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") and GunLookup[child.Name] then
        UpdateFireRate()
    end
end)

-- 9Ô∏è‚É£ Hook ‡∏¢‡∏¥‡∏á
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) then
            head = CurrentTarget.Character[TargetPartValue.Value]
            aimPos = PredictPosition(head)

            if MagicBulletEnabledValue.Value then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
                args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
                args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
            end
        end
    end
    return oldFire(self, unpack(args))
end)

-- üîü RenderStepped ‡∏õ‡∏£‡∏±‡∏ö polygon ‡πÅ‡∏•‡∏∞ tracer
RunService.RenderStepped:Connect(function()
    local center
    if AimModeValue.Value == "Center" then
        center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
        center = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end

    local radius = FOVRadiusValue.Value

    if not SilentAimEnabledValue.Value then
        for i = 1, sides do fovPolygon[i].Visible = false end
        tracerLine.Visible = false
        return
    end

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï polygon 10 ‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°
    local angleStep = 2*math.pi / sides
    local points = {}
    for i = 1, sides do
        local angle = angleStep * (i-1)
        points[i] = Vector2.new(center.X + math.cos(angle)*radius, center.Y + math.sin(angle)*radius)
    end
    for i = 1, sides do
        fovPolygon[i].From = points[i]
        fovPolygon[i].To = points[i % sides + 1] -- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏£‡∏≠‡∏ö‡∏ß‡∏á
        fovPolygon[i].Visible = true
    end

    -- Tracer Line
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild(TargetPartValue.Value) then
        local predictedPos = PredictPosition(target.Character[TargetPartValue.Value])
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            tracerLine.From = center
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- UI Toggles / Dropdown / Inputs
CombatTab:Toggle({
    Title = "Silent Aim",
    Icon = "circle-check",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state) SilentAimEnabledValue.Value = state end
})

CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Icon = "circle-check",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
        PREDICTION_FACTOR = state and 0 or PREDICTION_FACTOR_NORMAL
    end
})

CombatTab:Slider({
    Title = "FOV Radius",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value) FOVRadiusValue.Value = value end
})

CombatTab:Slider({
    Title = "Lock Distance",
    Step = 5,
    Value = {Min = 200, Max = 3000, Default = MaxLockDistanceValue.Value},
    Callback = function(value) MaxLockDistanceValue.Value = value end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","UpperTorso"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

CombatTab:Dropdown({
    Title = "Aim Mode",
    Values = {"Center", "Mouse"},
    Value = AimModeValue.Value,
    Callback = function(option) AimModeValue.Value = option end
})

CombatTab:Input({
    Title = "Ignore Players",
    Placeholder = "‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏•‡πá‡∏≠‡∏Ñ, ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,",
    InputIcon = "shield-check",
    Callback = function(txt)
        IgnorePlayers = {}
        for inputName in string.gmatch(txt, '([^,]+)') do
            inputName = inputName:match("^%s*(.-)%s*$")
            for _, plr in ipairs(Players:GetPlayers()) do
                if string.lower(plr.Name) == string.lower(inputName) then
                    table.insert(IgnorePlayers, plr.Name)
                end
            end
        end
    end
})

CombatTab:Divider()

CombatTab:Toggle({
    Title = "Magic Bullet",
    Icon = "circle-check",
    Value = MagicBulletEnabledValue.Value,
    Callback = function(state) MagicBulletEnabledValue.Value = state end
})

WeaponTab:Toggle({
    Title = "Enable Fire Rate",
    Icon = "circle-check",
    Value = FireRateEnabled.Value,
    Callback = function(state) FireRateEnabled.Value = state; UpdateFireRate() end
})

WeaponTab:Slider({
    Title = "Fire Rate",
    Step = 1,
    Value = {Min = 100, Max = 1000, Default = FireRateValue.Value},
    Callback = function(value)
        FireRateValue.Value = value
        UpdateFireRate()
    end
})
