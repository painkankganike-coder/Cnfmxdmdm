local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
local Window = WindUI:CreateWindow({
    Title = "Kaiju Hub | Pvp Paid üíµ",
    Icon = "gitlab",
    Author = "My Kaiju  | BlockSpinüî´",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "v 0.0.5 t",
    Icon = "cloud",
    Color = Color3.fromHex("#2889F7"),
    Radius = 13,
})

local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})

local WeaponTab = Window:Tab({Title = "WEAPON MODS:", Icon = "crosshair"})
WeaponTab:Section({Title="Gun Mods :"})

local CheaterTab = Window:Tab({Title = "CHEATER:", Icon = "user"})
CheaterTab:Section({Title="CHEATER :"})

local playerTab = Window:Tab({Title = "player:", Icon = "align-start-vertical"})
playerTab:Section({Title="Misc :"})

local EspTab = Window:Tab({Title = "Esp", Icon = "eye"})
EspTab:Section({Title="Esp PLAYER  :"})

local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="Server Hop  :"})



-- ‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Value = false
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Value = 150
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Value = 1000
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Value = "Head"
TargetPartValue.Name = "TargetPart"
TargetPartValue.Parent = LocalPlayer

local IgnorePlayers = {}

local CurrentTarget, head, aimPos
local hue = 0

-- ‡∏õ‡∏∑‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 2
tracerLine.Visible = false

-- ‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ö‡∏ô‡∏´‡∏±‡∏ß
local function GetPrediction(part)
    if not part or not part.Parent then return Vector3.new() end
    local partSize = (part:IsA("BasePart") and part.Size.Y or 1)
    return part.Position + Vector3.new(0, partSize/3, 0)
end

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏°‡∏µ‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

-- ‡∏ï‡∏£‡∏ß‡∏à IgnorePlayers
local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

-- ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏Å‡∏•‡πâ FOV ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏•‡πá‡∏≠‡∏Ñ
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            if player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ñ‡∏∑‡∏≠‡∏õ‡∏∑‡∏ô‡πÑ‡∏î‡πâ
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- Hook ‡∏¢‡∏¥‡∏á
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = GetPrediction(part)

            if MagicBulletValue.Value and IsBehindWall(head) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam ‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.15,0.15,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.fromHSV(math.random(),1,1)
            game:GetService("Debris"):AddItem(beam, 1)
        end
    end
    return oldFire(self, unpack(args))
end)

-- Render FOV + Tracer
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1)

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromHSV(hue, 1, 1)
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- WindUI Controls
CombatTab:Toggle({
    Title = "Silent Aim [ ‡∏¢‡∏¥‡∏á‡∏Å‡∏±‡∏ôLock‡πÑ‡∏î‡πâ  ]",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

CombatTab:Slider({
    Title = "FOV :",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value)
        FOVRadiusValue.Value = value
    end
})

CombatTab:Slider({
    Title = "Lock Distance :",
    Step = 25,
    Value = {Min = 50, Max = 1000, Default = LockDistanceValue.Value},
    Callback = function(value)
        LockDistanceValue.Value = value
    end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option)
        TargetPartValue.Value = option
    end
})

CombatTab:Toggle({
    Title = "Magic Bullet",
    Value = MagicBulletValue.Value,
    Callback = function(state)
        MagicBulletValue.Value = state
    end
})

-- Safe Players
CombatTab:Input({
    Title = "Safe Players",
    Placeholder = "‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Ñ, ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,",
    InputIcon = "shield-check",
    Callback = function(txt)
        IgnorePlayers = {}
        for inputName in string.gmatch(txt, '([^,]+)') do
            inputName = inputName:match("^%s*(.-)%s*$")
            table.insert(IgnorePlayers, inputName)
        end
    end
})

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó IgnorePlayers ‡∏ó‡∏∏‡∏Å 60 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏•‡∏ö‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°)
task.spawn(function()
    while true do
        task.wait(60)
        for i=#IgnorePlayers,1,-1 do
            local name = IgnorePlayers[i]
            local exists = false
            for _, plr in ipairs(Players:GetPlayers()) do
                if string.lower(plr.Name) == string.lower(name) then
                    exists = true
                    break
                end
            end
            if not exists then
                table.remove(IgnorePlayers, i)
            end
        end
    end
end)

CombatTab:Divider()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)

getgenv().NoRecoilEnabled = false

-- ‡πÄ‡∏Å‡πá‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô recoil ‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏¥‡∏î Recoil (‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
local function EnableNoRecoil()
    if getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = true

    -- override apply_recoil
    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
        -- ‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å original ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏î recoil 100%
    end

    -- loop ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö Recoil = 0
    antiLoop = task.spawn(function()
        while getgenv().NoRecoilEnabled do
            local char = Players.LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")
            if tool and tool:GetAttribute("Recoil") then
                tool:SetAttribute("Recoil", 0)
            end

            for _, gun in pairs(getgc(true)) do
                if typeof(gun) == "table" and rawget(gun, "instance") and gun.instance then
                    gun.instance:SetAttribute("Recoil", 0)
                end
            end

            task.wait(0.3)
        end
    end)

    print("‚úÖ No Recoil: ON")
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥ (‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
local function DisableNoRecoil()
    if not getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = false

    -- ‡∏Ñ‡∏∑‡∏ô recoil function ‡πÄ‡∏î‡∏¥‡∏°
    GunModule.apply_recoil = original_recoil

    -- ‡∏´‡∏¢‡∏∏‡∏î loop
    if antiLoop then
        task.cancel(antiLoop)
        antiLoop = nil
    end

    print("‚ùå No Recoil: OFF (‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ recoil ‡∏õ‡∏Å‡∏ï‡∏¥)")
end

-- üåü ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö UI
function ToggleNoRecoil(state)
    if state then
        EnableNoRecoil()
    else
        DisableNoRecoil()
    end
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Icon = "circle-check",
    Value = false,
    Callback = function(state)
        ToggleNoRecoil(state)
    end
})


WeaponTab:Section({Title="auto hit :"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
getgenv().HitAuraEnabled = false

-- ‡∏´‡∏≤ CounterTable ‡∏à‡∏≤‡∏Å getgc
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

local SendRemote
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    SendRemote = Remotes:WaitForChild("Send", 5)
end)

-- NetSend
local function NetSend(...)
    if not CounterTable or not CounterTable.event or not SendRemote then
        return
    end
    local args = {...}
    CounterTable.event = (CounterTable.event or 0) + 1
    pcall(function()
        SendRemote:FireServer(CounterTable.event, unpack(args))
    end)
end

-- getActiveTool
local function getActiveTool()
    local char = player.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then
            return obj
        end
    end
    return nil
end

-- getPlayersInRange
local function getPlayersInRange(radius)
    local inRange = {}
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

-- AttackNearby
local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = player.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            NetSend("melee_attack", tool, {target}, lookAtCFrame, 0.75)
        end
    end
end

-- Auto Loop
local autoLoop
local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

-- üåü ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Toggle (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å UI)
function ToggleHitAura(state)
    if state then
        getgenv().HitAuraEnabled = true
        StartHitAura()
        print("‚úÖ Hit Aura: ON")
    else
        StopHitAura()
        print("‚ùå Hit Aura: OFF")
    end
end

 WeaponTab:Toggle({
     Title = "Hit Aura",
     Icon = "circle-check",
     Default = false,
     Callback = function(state)
         ToggleHitAura(state)
     end
 })



local SpeedEnabled = false
local speedMultiplier = 0.10
local HideNameEnabled = false
local AntiLookEnabled = false
local AntiRagdollEnabled = false


CheaterTab:Slider({
    Title = "Speed Multiplier :",
    Value = {Min = 0.00, Max = 0.15, Default = speedMultiplier},
    Step = 0.05,
    Callback = function(value)
        speedMultiplier = value
    end
})


-- Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Speed
CheaterTab:Toggle({
    Title = "Speed",
    Value = SpeedEnabled,
    Callback = function(state)
        SpeedEnabled = state
    end
})

RunService.RenderStepped:Connect(function(delta)
    if SpeedEnabled and LocalPlayer.Character then
        local char = LocalPlayer.Character
        local hum = char:FindFirstChildOfClass("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if hum and root then
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                root.CFrame = root.CFrame + moveDir.Unit * speedMultiplier * delta * 60
            end
        end
    end
end)

local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

local JumpEnabled = false
local flying = false

-- ‡∏Ñ‡πà‡∏≤‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î
local jumpPower = 25
local jumpHeight = 25
local defaultJumpPower = 50
local defaultJumpHeight = 7.2
local flySpeed = 45

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î
local function ApplyJump(hum)
    if hum then
        hum.JumpPower = jumpPower
        hum.JumpHeight = jumpHeight
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
local function RemoveJump(hum)
    if hum then
        hum.JumpPower = defaultJumpPower
        hum.JumpHeight = defaultJumpHeight
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Humanoid ‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≠‡∏ô CharacterAdded
local function GetHumanoid()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChildOfClass("Humanoid")
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï HumanoidRootPart
local function GetRoot()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
end

-- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î
UIS.JumpRequest:Connect(function()
    if not JumpEnabled then return end
    flying = true
    local hum = GetHumanoid()
    if hum then
        hum:ChangeState(Enum.HumanoidStateType.Jumping)
        ApplyJump(hum)
    end
end)

-- ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏¥‡∏ô
UIS.InputEnded:Connect(function(input)
    if not JumpEnabled then return end
    if input.UserInputType == Enum.UserInputType.Keyboard or input.UserInputType == Enum.UserInputType.Touch then
        flying = false
    end
end)

-- Loop ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏ö‡∏¥‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if not JumpEnabled then return end
    local root = GetRoot()
    local hum = GetHumanoid()
    if not root or not hum then return end

    if flying then
        root.Velocity = Vector3.new(root.Velocity.X, flySpeed, root.Velocity.Z)
    else
        -- ‡πÉ‡∏ä‡πâ‡πÅ‡∏£‡∏á‡∏î‡∏∂‡∏á‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°
        root.Velocity = Vector3.new(root.Velocity.X, -30, root.Velocity.Z)
    end
end)

-- Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Jump+Fly
CheaterTab:Toggle({
    Title = "Jump",
    Value = JumpEnabled,
    Callback = function(state)
        JumpEnabled = state
        local hum = GetHumanoid()
        if state then
            ApplyJump(hum)
        else
            flying = false
            RemoveJump(hum)
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Jump ‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤
RunService.RenderStepped:Connect(function()
    if JumpEnabled and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            ApplyJump(hum)
        end
    end
end)

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö Spawn ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏¢
LocalPlayer.CharacterAdded:Connect(function(char)
    if JumpEnabled then
        char:WaitForChild("Humanoid")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            ApplyJump(hum)
        end
    end
end)

CheaterTab:Divider()

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö BillboardGui ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
local function RemoveBillboardGui()
    local char = LocalPlayer.Character
    if char then
        for _, gui in pairs(char:GetDescendants()) do
            if gui:IsA("BillboardGui") then
                gui:Destroy()
            end
        end
    end
end

-- Toggle Hide Name
CheaterTab:Toggle({
    Title = "Hide Name",
    Value = HideNameEnabled,
    Callback = function(state)
        HideNameEnabled = state
        if state then
            RemoveBillboardGui()
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï BillboardGui ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏° (Realtime)
RunService.RenderStepped:Connect(function()
    if HideNameEnabled and LocalPlayer.Character then
        for _, gui in pairs(LocalPlayer.Character:GetDescendants()) do
            if gui:IsA("BillboardGui") then
                gui:Destroy()
            end
        end
    end
end)

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ï‡∏≠‡∏ô Spawn ‡πÉ‡∏´‡∏°‡πà
LocalPlayer.CharacterAdded:Connect(function(char)
    if HideNameEnabled then
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ô Character ‡πÉ‡∏´‡∏°‡πà
        char.DescendantAdded:Connect(function(desc)
            if desc:IsA("BillboardGui") then
                desc:Destroy()
            end
        end)
        
        -- ‡∏•‡∏ö‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô Character
        RemoveBillboardGui()
    end
end)

local ANIM_ID = "rbxassetid://104767795538635"
local currentAnimTrack

local function PlayAntiLook()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local anim = Instance.new("Animation")
    anim.AnimationId = ANIM_ID
    currentAnimTrack = humanoid:LoadAnimation(anim)
    currentAnimTrack.Looped = true
    currentAnimTrack:Play()
end

local function StopAntiLook()
    if currentAnimTrack then
        currentAnimTrack:Stop()
        currentAnimTrack = nil
    end
end

CheaterTab:Toggle({
    Title = "Anti Lock",
    Value = AntiLookEnabled,
    Callback = function(state)
        AntiLookEnabled = state
        if state then PlayAntiLook() else StopAntiLook() end
    end
})

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
local UndergroundEnabled = false
local UndergroundAutoEnabled = true -- toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
local UndergroundDepth = 50       -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∂‡∏Å
local SpinSpeed = 2080            -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß
local UndergroundAngle = 0        -- ‡∏°‡∏∏‡∏°‡∏´‡∏°‡∏∏‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏°‡∏∏‡∏î
local function StartUnderground()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    UndergroundEnabled = true
    local initialY = hrp.Position.Y - UndergroundDepth

    local conn
    conn = RunService.RenderStepped:Connect(function(delta)
        if not UndergroundEnabled or not hrp.Parent then
            if conn then conn:Disconnect() conn = nil end
            return
        end

        UndergroundAngle = (UndergroundAngle + SpinSpeed * delta) % 360
        local rad = math.rad(UndergroundAngle)

        local offsetX = math.cos(rad) * 6 -- ‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ß‡∏á‡∏´‡∏°‡∏∏‡∏ô 6
        local offsetZ = math.sin(rad) * 6
        local newPos = Vector3.new(hrp.Position.X + offsetX, initialY, hrp.Position.Z + offsetZ)

        -- ‡∏´‡∏°‡∏∏‡∏ô‡∏´‡∏±‡∏ô‡πÑ‡∏õ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡∏•‡∏≤‡∏á‡∏ï‡∏±‡∏ß
        hrp.CFrame = CFrame.new(newPos, Vector3.new(hrp.Position.X, initialY, hrp.Position.Z))
    end)
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏°‡∏∏‡∏î
local function StopUnderground()
    UndergroundEnabled = false
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à Anti Ragdoll (‡πÑ‡∏°‡πà‡∏•‡πâ‡∏°)
local function AntiRagdoll()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end
    if humanoid.PlatformStand then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        hrp.Velocity = Vector3.new(0,0,0)
        hrp.RotVelocity = Vector3.new(0,0,0)
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end

    -- Underground Auto
    if UndergroundAutoEnabled then
        if humanoid.Health < 16 and humanoid.Health > 0 then
            if not UndergroundEnabled then StartUnderground() end
        elseif humanoid.Health >= 30 or humanoid.Health <= 0 then
            if UndergroundEnabled then StopUnderground() end
        end
    end

    -- Anti Ragdoll
    AntiRagdoll()
end)

-- Toggle ‡∏õ‡∏∏‡πà‡∏° UI
CheaterTab:Toggle({
    Title = "Anti Kill",
    Value = UndergroundAutoEnabled,
    Callback = function(state)
        UndergroundAutoEnabled = state
        if not state then UndergroundEnabled = false end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏£‡∏ì‡∏µ‡∏ï‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠ Respawn
Players.LocalPlayer.CharacterAdded:Connect(function(char)
    if UndergroundAutoEnabled then
        UndergroundEnabled = false
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local CounterTable

-- ‡∏´‡∏≤ CounterTable
local function findCounter()
    for _, obj in ipairs(getgc(true)) do
        if typeof(obj) == "table" and rawget(obj, "event") and rawget(obj, "func") then
            return obj
        end
    end
    return nil
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏° Anti Ragdoll
local function startAntiRagdoll()
    CounterTable = findCounter()
    if not CounterTable then
        warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö CounterTable!")
        return
    end

    spawn(function()
        while AntiRagdollEnabled do
            CounterTable.event = (CounterTable.event or 0) + 1
            local SendRemote = ReplicatedStorage.Remotes:WaitForChild("Send")
            pcall(function()
                SendRemote:FireServer(CounterTable.event, "end_ragdoll_early")
            end)
            wait(0.3)

            if AntiRagdollEnabled then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "clear_ragdoll")
                end)
            end
            wait(0.3)
        end
    end)
end

-- WindUI Toggle
CheaterTab:Toggle({
    Title = "Anti Ragdoll",
    Value = AntiRagdollEnabled,
    Callback = function(state)
        AntiRagdollEnabled = state
        if AntiRagdollEnabled then
            startAntiRagdoll()
            print("‚úÖ Anti Ragdoll ON")
        else
            print("‚ùå Anti Ragdoll OFF")
        end
    end
})

-- Auto start ‡πÄ‡∏°‡∏∑‡πà‡∏≠ respawn
player.CharacterAdded:Connect(function()
    if AntiRagdollEnabled then
        wait(1)
        startAntiRagdoll()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local rootPart = char:WaitForChild("HumanoidRootPart")

-- ‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Toggle ‡πÑ‡∏ß‡πâ
local PickupEnabled = false

-- ‡∏´‡∏≤ CounterTable
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

-- NetGet Function
local function NetGet(...)
    if not CounterTable or not CounterTable.func then return end
    local args = {...}
    CounterTable.func = (CounterTable.func or 0) + 1
    local success, result = pcall(function()
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))
    end)
    if not success then warn("[NetGet Error]", result) end
    return result
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°
local function CheckAndPickup()
    if not PickupEnabled then return end
    if not rootPart or not rootPart.Parent then return end

    local droppedFolder = workspace:FindFirstChild("DroppedItems") or workspace:FindFirstChild("DroppedItem")
    if not droppedFolder then return end

    for _, item in ipairs(droppedFolder:GetChildren()) do
        if item.Name == "Money" then continue end
        if item:IsA("Model") and item:FindFirstChildWhichIsA("BasePart") then
            local success, modelCF = pcall(function()
                return (item.GetPivot and item:GetPivot() or item:GetModelCFrame())
            end)
            if not success or not modelCF then continue end
            local distance = (rootPart.Position - modelCF.Position).Magnitude
            if distance <= 15 then
                pcall(function()
                    NetGet("pickup_dropped_item", item)
                end)
            end
        end
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï char ‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠ Spawn / ‡∏ï‡∏≤‡∏¢
local function UpdateChar(newChar)
    char = newChar
    rootPart = char:WaitForChild("HumanoidRootPart")
end

player.CharacterAdded:Connect(UpdateChar)
if char then
    UpdateChar(char)
end

-- Loop ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.Heartbeat:Connect(CheckAndPickup)

-- WindUI Toggle
CheaterTab:Toggle({
    Title = "Pickup Items",
    Value = PickupEnabled,
    Callback = function(state)
        PickupEnabled = state
        print("üß≤ Auto Pickup Items:", state and "ON" or "OFF")
    end
})

CheaterTab:Slider({
    Title = "Stamina :",
    Step = 1,
    Value = {
        Min = 120,
        Max = 99999,
        Default = 100,
    },
    Callback = function(value)
        local player = game.Players.LocalPlayer
        player:SetAttribute("MaxStamina", value)
        print("[‚úÖ] ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤ MaxStamina =", value)
    end
})

CheaterTab:Divider()
CheaterTab:Section({Title="Snap PC key [ Z ]"})

local SnapHeightOffset = -7
local SnapDirection = "Down"
local SnapDuration = 0.1
local SnapBlockDuration = 3 -- ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¢‡∏π‡πà
local isRunning = false

local function SnapQuick()
    if isRunning then return end
    isRunning = true

    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then isRunning=false return end

    -- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å Neon ‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÅ‡∏™‡∏á‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß
    local blocks = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            local blk = Instance.new("Part")
            blk.Size = part.Size
            blk.CFrame = part.CFrame
            blk.Anchored = true
            blk.CanCollide = false
            blk.Material = Enum.Material.Neon
            blk.Transparency = 0.5
            blk.Color = Color3.fromRGB(255,255,255)
            blk.Parent = workspace
            table.insert(blocks, blk)
        end
    end

    -- ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    task.spawn(function()
        task.wait(SnapBlockDuration)
        for _, blk in ipairs(blocks) do
            if blk and blk.Parent then blk:Destroy() end
        end
    end)

    -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏°‡∏∏‡∏î
    hum.Sit = true
    local origY = hrp.Position.Y
    local offset = math.abs(SnapHeightOffset)
    if SnapDirection == "Down" then offset = -offset end

    -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏ö‡∏ö real-time ‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if hrp and hrp.Parent then
            hrp.CFrame = hrp.CFrame:Lerp(CFrame.new(hrp.Position.X, origY+offset, hrp.Position.Z),0.8)

            -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤
            for i, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") and blocks[i] then
                    local blk = blocks[i]
                    if blk and blk.Parent then
                        blk.CFrame = part.CFrame
                    end
                end
            end
        end
    end)

    task.wait(SnapDuration)
    if conn then conn:Disconnect() conn=nil end
    hum.Sit = false
    isRunning=false
end

-- ‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡∏∞ Hotkey
CheaterTab:Button({
    Title="Snap Click",
    Locked=false,
    Callback=function() SnapQuick() end
})

CheaterTab:Slider({
    Title="Snap Depth",
    Step=1,
    Value={Min=1,Max=50,Default=math.abs(SnapHeightOffset)},
    Callback=function(val)
        SnapHeightOffset=(SnapDirection=="Down" and -1 or 1)*val
    end
})

CheaterTab:Dropdown({
    Title="Snap Direction",
    Values={"Down","Up"},
    Value=SnapDirection,
    Callback=function(opt)
        SnapDirection=opt
        SnapHeightOffset=(opt=="Down" and -1 or 1)*math.abs(SnapHeightOffset)
    end
})

UserInputService.InputBegan:Connect(function(input,gpe)
    if gpe then return end
    if input.KeyCode==Enum.KeyCode.Z then SnapQuick() end
end)

local player = game.Players.LocalPlayer
getgenv().SkipCrateEnabled = false


local ReplicatedStorage = game:GetService("ReplicatedStorage")


local SendRemote
local connection

-- TrySkipCrate Function (copy ‡∏à‡∏≤‡∏Å‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö 100%)
local function TrySkipCrate()
    local success, CrateController = pcall(function()
        return require(ReplicatedStorage.Modules.Game.CrateSystem.Crate)
    end)
    if success and CrateController and CrateController.spinning and CrateController.spinning.get() then
        CrateController.skip_spin()
        print("‚úÖ Skip Crate Spin!")
    end
end

-- Setup Auto Skip (listen Send.OnClientEvent)
local function SetupAutoSkip()
    if connection then
        connection:Disconnect()
    end
    
    pcall(function()
        connection = SendRemote.OnClientEvent:Connect(function(...)
            if getgenv().SkipCrateEnabled then
                task.spawn(TrySkipCrate)
            end
        end)
    end)
end

-- Enable / Disable Functions
local function EnableSkipCrate()
    getgenv().SkipCrateEnabled = true
    SetupAutoSkip()
    TrySkipCrate()  -- Skip ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    print("ü™£ SkipCrate: ON | Auto Skip Spin ‡∏ó‡∏∏‡∏Å Crate!")
end

local function DisableSkipCrate()
    getgenv().SkipCrateEnabled = false
    if connection then
        connection:Disconnect()
    end
    print("ü™£ SkipCrate: OFF")
end

-- Setup Remotes
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    SendRemote = Remotes:WaitForChild("Send", 10)
end)

-- ======= WindUI Toggle =======
playerTab:Toggle({
    Title = "Skip Crate",
    Icon = "circle-check",  -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    Value = getgenv().SkipCrateEnabled,
    Callback = function(state)
        getgenv().SkipCrateEnabled = state
        if state then
            EnableSkipCrate()
        else
            DisableSkipCrate()
        end
    end
})

-- Info
if SendRemote then
    print("‚úÖ BlockSpin SkipCrate Loaded! | Toggle ‡∏ú‡πà‡∏≤‡∏ô UI ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢")
else
    warn("‚ùå Remotes.Send ‡πÑ‡∏°‡πà‡∏û‡∏ö! ‡∏£‡∏≠‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà")
end

-- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ WindUI ‡πÅ‡∏•‡∏∞ Tab ‡∏ó‡∏µ‡πà‡∏ä‡∏∑‡πà‡∏≠ CheaterTab ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- ‡∏´‡∏≤ CounterTable ‡∏à‡∏≤‡∏Å getgc
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

-- Net.get Function
local Net = {}
local function NetGet(...)
    if not CounterTable or not CounterTable.func then
        warn("‚ùå CounterTable ‡πÑ‡∏°‡πà‡∏û‡∏ö!")
        return
    end
    local args = {...}
    CounterTable.func = (CounterTable.func or 0) + 1
    local success, result = pcall(function()
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))
    end)
    if not success then
        warn("[NetGet Error]", result)
    end
    return result
end
function Net.get(...)
    return NetGet(...)
end

-- Claim All Function
local function ClaimAllQuests()
    local success, questFrame = pcall(function()
        return player:WaitForChild("PlayerGui"):WaitForChild("Quests"):WaitForChild("QuestsHolder"):WaitForChild("QuestsScrollingFrame")
    end)
    if not success or not questFrame then
        warn("‚ùå Quest GUI ‡πÑ‡∏°‡πà‡∏û‡∏ö! (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î Quests)")
        return 0
    end
    
    local claimed = 0
    for _, child in ipairs(questFrame:GetChildren()) do
        if (child:IsA("Frame") or child:IsA("TextButton") or child:IsA("ImageButton")) and child.Name ~= "" then
            pcall(function()
                Net.get("claim_quest", child.Name)
            end)
            claimed = claimed + 1
            task.wait(0.2)
        end
    end
    return claimed
end

playerTab:Button({
    Title = "Claim All Quests",
    Locked = false,
    Callback = function()
        local claimed = ClaimAllQuests()  -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô ClaimAllQuests
        if claimed > 0 then
            print("‚úÖ Claimed", claimed, "Quests!")
        else
            print("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ Quest ‡πÉ‡∏´‡πâ Claim")
        end
    end
})

playerTab:Divider()
playerTab:Section({Title="virus player :"})

local RunService = game:GetService("RunService")
local BlocksEnabled = false
local RainbowBlocks = {}

local NumBlocks = 10       -- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ö‡∏•‡πá‡∏≠‡∏Å
local Radius = 2          -- ‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ß‡∏á‡∏Å‡∏•‡∏°‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß
local Height = 3          -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß
local BlockSize = Vector3.new(0.5, 0.5, 0.5) -- ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ö‡∏•‡πá‡∏≠‡∏Å
local SpinSpeed = 60        -- ‡∏≠‡∏á‡∏®‡∏≤‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏£‡∏≠‡∏ö‡∏´‡∏±‡∏ß
local function CreateBlocks()
    -- ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏Å‡πà‡∏≤
    for _, b in pairs(RainbowBlocks) do
        if b and b.Parent then b:Destroy() end
    end
    RainbowBlocks = {}

    for i = 1, NumBlocks do
        local part = Instance.new("Part")
        part.Size = BlockSize
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromHSV(math.random(),1,1)
        part.Parent = workspace
        RainbowBlocks[i] = part
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏ô‡∏ö‡∏•‡πá‡∏≠‡∏Å
RunService.RenderStepped:Connect(function(delta)
    if not BlocksEnabled then
        for _, b in pairs(RainbowBlocks) do
            if b and b.Parent then b:Destroy() end
        end
        RainbowBlocks = {}
        return
    end

    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local time = tick()
    for i, part in ipairs(RainbowBlocks) do
        if part and part.Parent then
            -- ‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á‡πÑ‡∏•‡πà‡πÄ‡∏ß‡∏•‡∏≤
            part.Color = Color3.fromHSV((tick() + i*0.05) % 1,1,1)

            -- ‡∏°‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏£‡∏≠‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏°
            local angle = math.rad((i-1)/NumBlocks*360 + time*SpinSpeed)
            local offset = Vector3.new(math.cos(angle)*Radius, Height, math.sin(angle)*Radius)

            part.CFrame = CFrame.new(hrp.Position + offset)
        end
    end
end)

-- Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
playerTab:Toggle({
    Title = "Rainbow king",
    Icon = "circle-check",
    Value = BlocksEnabled,
    Callback = function(state)
        BlocksEnabled = state
        if state then CreateBlocks() end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

local rootBlock -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å
local UpdateInterval = 0.1 -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
local hue = 0 -- ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Ñ‡∏£‡∏≠‡∏ö HumanoidRootPart
local function CreateRootBlock()
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô
    if rootBlock then
        rootBlock:Destroy()
        rootBlock = nil
    end

    -- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà
    rootBlock = Instance.new("Part")
    rootBlock.Size = hrp.Size
    rootBlock.CFrame = hrp.CFrame
    rootBlock.Anchored = true
    rootBlock.CanCollide = false
    rootBlock.Transparency = 0.3
    rootBlock.Material = Enum.Material.Neon
    rootBlock.Parent = workspace

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á
    spawn(function()
        while rootBlock and rootBlock.Parent and hrp.Parent do
            rootBlock.CFrame = hrp.CFrame
            hue = (hue + 0.05) % 1 -- ‡πÄ‡∏û‡∏¥‡πà‡∏° hue ‡∏ó‡∏µ‡∏•‡∏∞ 0.05
            rootBlock.Color = Color3.fromHSV(hue, 1, 1)
            task.wait(UpdateInterval)
        end
    end)
end

-- ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å
local function RemoveRootBlock()
    if rootBlock then
        rootBlock:Destroy()
        rootBlock = nil
    end
end

-- Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
playerTab:Toggle({
    Title = "king rainbow üåà",
    Value = false,
    Callback = function(state)
        if state then
            CreateRootBlock()
        else
            RemoveRootBlock()
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏ß‡∏•‡∏≤ Respawn
player.CharacterAdded:Connect(function(char)
    if rootBlock then
        CreateRootBlock()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local highlight = nil
local toggleHighlight = false
local interval = 15 -- ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏µ‡∏ó‡∏∏‡∏Å 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
local colorState = true -- true = ‡∏Ç‡∏≤‡∏ß, false = ‡∏î‡∏≥

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight
local function CreateHighlight()
    local char = player.Character
    if not char then return end

    -- ‡∏•‡∏ö highlight ‡πÄ‡∏Å‡πà‡∏≤
    if highlight then
        highlight:Destroy()
        highlight = nil
    end

    highlight = Instance.new("Highlight")
    highlight.FillTransparency = 0 -- ‡∏ó‡∏∂‡∏ö‡∏™‡∏∏‡∏î
    highlight.OutlineTransparency = 0
    highlight.Parent = char
    highlight.Adornee = char

    -- Loop ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏™‡∏•‡∏±‡∏ö ‡∏Ç‡∏≤‡∏ß ‚Üî ‡∏î‡∏≥
    spawn(function()
        while highlight and highlight.Parent and toggleHighlight do
            if colorState then
                highlight.FillColor = Color3.fromRGB(255,255,255)
                highlight.OutlineColor = Color3.fromRGB(255,255,255)
            else
                highlight.FillColor = Color3.fromRGB(0,0,0)
                highlight.OutlineColor = Color3.fromRGB(0,0,0)
            end
            colorState = not colorState
            task.wait(interval)
        end
    end)
end

-- ‡∏•‡∏ö Highlight
local function RemoveHighlight()
    if highlight then
        highlight:Destroy()
        highlight = nil
    end
end

-- Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Highlight
playerTab:Toggle({
    Title = "BW Highlight",
    Value = false,
    Callback = function(state)
        toggleHighlight = state
        if state then
            CreateHighlight()
        else
            RemoveHighlight()
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏ß‡∏•‡∏≤ Respawn
player.CharacterAdded:Connect(function(char)
    if toggleHighlight then
        CreateHighlight()
    end
end)

playerTab:Divider()
playerTab:Section({Title="box tool :"})

playerTab:Button({
    Title = "troll Script BMX [ ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏Å‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô  ]",
    Callback = function()
        task.spawn(function()
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            
            local player = Players.LocalPlayer
            local playerGui = player:WaitForChild("PlayerGui")
            
            local character = player.Character or player.CharacterAdded:Wait()
            local rootPart = character:WaitForChild("HumanoidRootPart")
            
            -- ‡∏´‡∏≤ BMX
            local frontWheel = workspace:WaitForChild("Vehicles"):WaitForChild("BMX"):WaitForChild("Wheels"):WaitForChild("Front", 8)
            local rearWheel  = workspace:WaitForChild("Vehicles"):WaitForChild("BMX"):WaitForChild("Wheels"):WaitForChild("Rear", 8)
            local framePart  = workspace:WaitForChild("Vehicles"):WaitForChild("BMX"):WaitForChild("Colliders"):WaitForChild("Part", 8)
            
            local validParts = {}
            for _, p in {frontWheel, rearWheel, framePart} do
                if p then table.insert(validParts, p) end
            end
            if #validParts == 0 then return end
            
            -- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
            local kickForce = 16384
            local bounceSpeed = 0.003
            local cooldown = 0
            local lastTime = 0
            local isEnabled = false
            local selectedPlayer = nil
            
            -- ‡∏™‡∏£‡πâ‡∏≤‡∏á GUI
            local sg = Instance.new("ScreenGui")
            sg.ResetOnSpawn = false
            sg.Parent = playerGui
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(0, 160, 0, 60)
            frame.Position = UDim2.new(0, 20, 0, 20)
            frame.BackgroundColor3 = Color3.fromRGB(240,240,240)
            frame.BorderColor3 = Color3.fromRGB(180,180,180)
            frame.BorderSizePixel = 1
            frame.Active = true
            frame.Draggable = true
            frame.Parent = sg
            
            local nameBox = Instance.new("TextBox")
            nameBox.Size = UDim2.new(0.55,0,0,25)
            nameBox.Position = UDim2.new(0.03,0,0.15,0)
            nameBox.BackgroundColor3 = Color3.fromRGB(255,255,255)
            nameBox.BorderColor3 = Color3.fromRGB(180,180,180)
            nameBox.BorderSizePixel = 1
            nameBox.PlaceholderText = "‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô"
            nameBox.Text = ""
            nameBox.TextColor3 = Color3.new(0,0,0)
            nameBox.Font = Enum.Font.Gotham
            nameBox.TextScaled = true
            nameBox.Parent = frame
            
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(0.35,0,0,25)
            btn.Position = UDim2.new(0.62,0,0.15,0)
            btn.BackgroundColor3 = Color3.fromRGB(150,150,150)
            btn.BorderColor3 = Color3.fromRGB(180,180,180)
            btn.BorderSizePixel = 1
            btn.Text = "OFF"
            btn.TextScaled = true
            btn.Font = Enum.Font.GothamBold
            btn.Parent = frame
            
            local dropdown = Instance.new("Frame")
            dropdown.Size = UDim2.new(0.55,0,0,90)
            dropdown.Position = UDim2.new(0.03,0,0.45,0)
            dropdown.BackgroundColor3 = Color3.fromRGB(255,255,255)
            dropdown.BorderColor3 = Color3.fromRGB(180,180,180)
            dropdown.BorderSizePixel = 1
            dropdown.Visible = false
            dropdown.ClipsDescendants = true
            dropdown.Parent = frame
            
            local list = Instance.new("UIListLayout", dropdown)
            
            local function updateDropdown()
                for _, v in dropdown:GetChildren() do if v:IsA("TextButton") then v:Destroy() end end
                local text = nameBox.Text:lower()
                if #text < 1 then dropdown.Visible = false; return end
                
                local matches = {}
                for _, plr in Players:GetPlayers() do
                    if plr ~= player and plr.Name:lower():find(text,1,true) then
                        table.insert(matches, plr)
                    end
                end
                
                if #matches == 0 then dropdown.Visible = false; return end
                
                dropdown.Visible = true
                dropdown.Size = UDim2.new(0.55,0,0,math.min(#matches*25,90))
                
                for _, plr in matches do
                    local item = Instance.new("TextButton", dropdown)
                    item.Size = UDim2.new(1,0,0,25)
                    item.BackgroundColor3 = Color3.fromRGB(220,220,220)
                    item.BorderColor3 = Color3.fromRGB(180,180,180)
                    item.BorderSizePixel = 1
                    item.Text = plr.Name
                    item.TextColor3 = Color3.new(0,0,0)
                    item.Font = Enum.Font.Gotham
                    item.TextScaled = true
                    
                    item.MouseButton1Click:Connect(function()
                        nameBox.Text = plr.Name
                        selectedPlayer = plr
                        dropdown.Visible = false
                        updateUI()
                    end)
                end
            end
            
            nameBox:GetPropertyChangedSignal("Text"):Connect(updateDropdown)
            nameBox.FocusLost:Connect(function() task.wait(0.1); dropdown.Visible = false end)
            
            local function updateUI()
                if not selectedPlayer then
                    btn.Text = "OFF"
                    btn.BackgroundColor3 = Color3.fromRGB(150,150,150)
                elseif isEnabled then
                    btn.Text = "ON"
                    btn.BackgroundColor3 = Color3.fromRGB(200,200,200)
                else
                    btn.Text = "OFF"
                    btn.BackgroundColor3 = Color3.fromRGB(150,150,150)
                end
            end
            
            btn.MouseButton1Click:Connect(function()
                if selectedPlayer then
                    isEnabled = not isEnabled
                    updateUI()
                end
            end)
            
            local function getTarget()
                if not selectedPlayer or not selectedPlayer.Character then return nil end
                local char = selectedPlayer.Character
                if not char:FindFirstChild("HumanoidRootPart") then return nil end
                local hrp = char.HumanoidRootPart
                
                local pos
                if math.random() < 0.5 then
                    local u = char:FindFirstChild("UpperTorso")
                    local l = char:FindFirstChild("LowerTorso")
                    pos = u and l and (u.Position + l.Position)/2 or hrp.Position
                else
                    local lf = char:FindFirstChild("LeftFoot") or char:FindFirstChild("Left Foot")
                    local rf = char:FindFirstChild("RightFoot") or char:FindFirstChild("Right Foot")
                    pos = lf and rf and (lf.Position + rf.Position)/2 or hrp.Position - Vector3.new(0,3,0)
                end
                return {pos = pos, hrp = hrp}
            end
            
            local function attack(t)
                if not t or tick() - lastTime < cooldown then return end
                lastTime = tick()
                local core = t.pos
                
                for _, p in validParts do
                    if p and p.Parent then
                        p.CFrame = CFrame.new(core + Vector3.new(math.random(-2,2), math.random(-1,1), math.random(-2,2)))
                    end
                end
                
                task.spawn(function()
                    for i = 1, 50 do
                        for a = 0, 360, 1 do
                            task.wait(bounceSpeed)
                            local r = 6 + math.sin(i*1.5 + a*0.3)*4
                            local pos = core + Vector3.new(math.cos(math.rad(a*12+i*20))*r, math.abs(math.sin(math.rad(a*15)))*3, math.sin(math.rad(a*14+i*25))*r)
                            local rot = CFrame.Angles(math.rad(a*40+i*50), math.rad(a*45), math.rad(a*35 + math.sin(tick()*100)*200))
                            for _, p in validParts do if p and p.Parent then p.CFrame = CFrame.new(pos)*rot end end
                        end
                    end
                end)
                
                task.delay(0.3, function()
                    local dir = (t.hrp.Position - rootPart.Position).Unit + Vector3.new(0,2,0)
                    local vel = dir * kickForce
                    for _, p in validParts do if p and p.Parent then p.Velocity = vel + Vector3.new(math.random(-100,100), math.random(150,250), math.random(-100,100)) end end
                    pcall(function()
                        local bv = Instance.new("BodyVelocity")
                        bv.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
                        bv.Velocity = vel * 3
                        bv.Parent = t.hrp
                        game.Debris:AddItem(bv, 0.5)
                    end)
                end)
            end
            
            RunService.Heartbeat:Connect(function()
                if isEnabled and selectedPlayer then
                    local t = getTarget()
                    if t then attack(t) end
                end
            end)
            
            player.CharacterAdded:Connect(function(c)
                character = c
                rootPart = c:WaitForChild("HumanoidRootPart")
            end)
            
            updateUI()
        end)
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer


playerTab:Button({
    Title = "box Snap",
    Callback = function()
        -- GUI Setup
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local Humanoid = Character:WaitForChild("Humanoid")
        local HRP = Character:WaitForChild("HumanoidRootPart")
        local isRunning = false
        local sitConnection = nil
        local heightOffset = -7
        local speed = 0.8
        local duration = 0.1

        -- ‡∏™‡∏£‡πâ‡∏≤‡∏á ScreenGui
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "SitRealOneShotGUI"
        ScreenGui.Parent = game:GetService("CoreGui")
        ScreenGui.ResetOnSpawn = false

        local Frame = Instance.new("Frame")
        Frame.Parent = ScreenGui
        Frame.BackgroundColor3 = Color3.fromRGB(0,0,0)
        Frame.BorderSizePixel = 2
        Frame.BorderColor3 = Color3.fromRGB(255,255,255)
        Frame.Position = UDim2.new(0,10,0.5,-27)
        Frame.Size = UDim2.new(0,133,0,53)
        Frame.Active = true
        Frame.Draggable = true

        local ActionButton = Instance.new("TextButton")
        ActionButton.Parent = Frame
        ActionButton.BackgroundColor3 = Color3.fromRGB(255,255,255)
        ActionButton.BorderSizePixel = 0
        ActionButton.Position = UDim2.new(0,10,0,7)
        ActionButton.Size = UDim2.new(0,113,0,27)
        ActionButton.Font = Enum.Font.GothamBold
        ActionButton.Text = "‡∏°‡∏∏‡∏î‡∏î‡∏¥‡∏ô‡∏î‡∏¥!?"
        ActionButton.TextColor3 = Color3.fromRGB(0,0,0)
        ActionButton.TextSize = 13

        local StatusLabel = Instance.new("TextLabel")
        StatusLabel.Parent = Frame
        StatusLabel.BackgroundTransparency = 1
        StatusLabel.Position = UDim2.new(0,10,0,37)
        StatusLabel.Size = UDim2.new(0,113,0,13)
        StatusLabel.Font = Enum.Font.Gotham
        StatusLabel.Text = "‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏•‡∏∞"
        StatusLabel.TextColor3 = Color3.fromRGB(0,255,0)
        StatusLabel.TextSize = 10

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏°
        local function StartSitReal()
            if isRunning then return end
            isRunning = true
            Character = LocalPlayer.Character
            if not Character then isRunning = false; return end
            Humanoid = Character:FindFirstChild("Humanoid")
            HRP = Character:FindFirstChild("HumanoidRootPart")
            if not Humanoid or not HRP then isRunning = false; return end
            Humanoid.Sit = true

            sitConnection = RunService.RenderStepped:Connect(function()
                if HRP and HRP.Parent then
                    local targetY = HRP.Position.Y + heightOffset
                    local currentCFrame = HRP.CFrame
                    local targetCFrame = CFrame.new(currentCFrame.X, targetY, currentCFrame.Z) * (currentCFrame - currentCFrame.Position)
                    HRP.CFrame = currentCFrame:Lerp(targetCFrame, speed)
                end
            end)
        end

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏à‡∏°
        local function StopSitReal()
            if sitConnection then
                sitConnection:Disconnect()
                sitConnection = nil
            end
            if Humanoid then
                Humanoid.Sit = false
            end
            isRunning = false
        end

        -- ‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        ActionButton.MouseButton1Click:Connect(function()
            if isRunning then
                StatusLabel.Text = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô..."
                StatusLabel.TextColor3 = Color3.fromRGB(255,255,0)
                return
            end

            StatusLabel.Text = "‡∏à‡∏°‡∏î‡∏¥‡∏ô‡∏•‡∏∞‡πÑ‡∏≠‡πâ‡∏´‡∏•‡πà‡∏≠‡∏ô"
            StatusLabel.TextColor3 = Color3.fromRGB(255,200,0)
            ActionButton.Text = "‡πÑ‡∏≠‡πâ‡∏´‡∏±‡∏ß‡∏Ñ.."

            StartSitReal()
            task.wait(duration)
            StopSitReal()

            StatusLabel.Text = "‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô"
            StatusLabel.TextColor3 = Color3.fromRGB(0,255,0)
            ActionButton.Text = "‡∏°‡∏∏‡∏î‡∏î‡∏¥‡∏ô!?!?"

            task.wait(0.5)
            StatusLabel.Text = "‡∏°‡∏∏‡∏î‡∏î‡∏¥‡∏ô‡∏ã‡∏∑‡πâ‡∏≠‡∏°‡∏∂‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß"
        end)

        -- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
        LocalPlayer.CharacterAdded:Connect(function(newChar)
            task.wait(1)
            Character = newChar
            Humanoid = newChar:WaitForChild("Humanoid")
            HRP = newChar:WaitForChild("HumanoidRootPart")
        end)

        -- ‡∏õ‡∏¥‡∏î GUI ‡∏î‡πâ‡∏ß‡∏¢ Delete
        UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.Delete then
                StopSitReal()
                ScreenGui:Destroy()
            end
        end)
    end
})


local Players = game:GetService("Players")  
local RunService = game:GetService("RunService")  
local Workspace = game:GetService("Workspace")  
local LocalPlayer = Players.LocalPlayer  
local camera = Workspace.CurrentCamera  

-- Config  
local BOX_COLOR = Color3.fromRGB(255, 255, 255)  
local BOX_THICKNESS = 2  
local SCALE_MULTIPLIER = 1  

-- Table ‡πÄ‡∏Å‡πá‡∏ö ESP ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô  
local espPlayers = {}  

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤ (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)  
local CurrentTarget = nil  -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ  

-- ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏•‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠  
local function worldToViewport(pos)  
    local screen, onScreen = camera:WorldToViewportPoint(pos)  
    return Vector2.new(screen.X, screen.Y), onScreen  
end  

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box ESP  
local function createBoxESP(plr)  
    if espPlayers[plr] or plr == LocalPlayer then return end  

    local lines = {}  
    for i = 1, 12 do  
        local line = Drawing.new("Line")  
        line.Visible = false  
        line.Color = BOX_COLOR  
        line.Thickness = BOX_THICKNESS  
        line.Transparency = 1  
        lines[i] = line  
    end  

    local connection = RunService.RenderStepped:Connect(function()  
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then  
            for _, line in ipairs(lines) do line.Visible = false end  
            return  
        end  

        local root = plr.Character.HumanoidRootPart  
        local rootPos = root.Position  
        local scale = root.Size.Y * SCALE_MULTIPLIER  

        local corners = {  
            Vector3.new(-1,  2, -1), Vector3.new( 1,  2, -1), Vector3.new( 1,  2,  1), Vector3.new(-1,  2,  1),  
            Vector3.new(-1, -2, -1), Vector3.new( 1, -2, -1), Vector3.new( 1, -2,  1), Vector3.new(-1, -2,  1)  
        }  

        local screenCorners = {}  
        local allOnScreen = true  

        for i, offset in ipairs(corners) do  
            local worldPos = rootPos + (root.CFrame:VectorToWorldSpace(offset * scale))  
            local screenPos, onScreen = worldToViewport(worldPos)  
            screenCorners[i] = screenPos  
            if not onScreen then allOnScreen = false end  
        end  

        if not allOnScreen then  
            for _, line in ipairs(lines) do line.Visible = false end  
            return  
        end  

        -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô  
        local color = (CurrentTarget == plr) and Color3.fromRGB(255,0,0) or BOX_COLOR  

        local edges = {  
            {1,2},{2,3},{3,4},{4,1},  
            {5,6},{6,7},{7,8},{8,5},  
            {1,5},{2,6},{3,7},{4,8}  
        }  

        for i, edge in ipairs(edges) do  
            local line = lines[i]  
            line.From = screenCorners[edge[1]]  
            line.To = screenCorners[edge[2]]  
            line.Color = color  -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏™‡∏µ  
            line.Visible = true  
        end  
    end)  

    espPlayers[plr] = {connection = connection, lines = lines}  
end  

-- ‡∏•‡∏ö Box ESP  
local function removeBoxESP(plr)  
    if espPlayers[plr] then  
        if espPlayers[plr].connection then espPlayers[plr].connection:Disconnect() end  
        for _, line in ipairs(espPlayers[plr].lines) do line:Remove() end  
        espPlayers[plr] = nil  
    end  
end  

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î  
local function enableAllESP()  
    for _, plr in pairs(Players:GetPlayers()) do  
        if plr ~= LocalPlayer then createBoxESP(plr) end  
    end  
end  

-- ‡∏•‡∏ö ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î  
local function disableAllESP()  
    for plr, _ in pairs(espPlayers) do  
        removeBoxESP(plr)  
    end  
end  

-- Player Added/Removing  
Players.PlayerAdded:Connect(function(plr)  
    task.wait(1)  
    if _G.ESPEnabled then createBoxESP(plr) end  
end)  
Players.PlayerRemoving:Connect(removeBoxESP)  

-- WindUi Toggle  
EspTab:Toggle({  
    Title = "Box",  
    Icon = "eye",  
    Default = false,  
    Callback = function(state)  
        _G.ESPEnabled = state  
        if state then  
            enableAllESP()  
            print("‚úÖ ESP Box: ON")  
        else  
            disableAllESP()  
            print("‚ùå ESP Box: OFF")  
        end  
    end  
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- BoolValue ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ESP
local ESPNameEnabled = Instance.new("BoolValue")
ESPNameEnabled.Name = "ESPNameEnabled"
ESPNameEnabled.Value = false
ESPNameEnabled.Parent = LocalPlayer

local ESPDistanceEnabled = Instance.new("BoolValue")
ESPDistanceEnabled.Name = "ESPDistanceEnabled"
ESPDistanceEnabled.Value = false
ESPDistanceEnabled.Parent = LocalPlayer

local espDistanceTable = {} -- ‡πÄ‡∏Å‡πá‡∏ö GUI ‡∏£‡∏∞‡∏¢‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó ESP Name
local function UpdateNameESP()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            local head = plr.Character.Head
            local gui = head:FindFirstChild("NameESP")
            if ESPNameEnabled.Value then
                if not gui then
                    local bill = Instance.new("BillboardGui")
                    bill.Name = "NameESP"
                    bill.Adornee = head
                    bill.Parent = head
                    bill.Size = UDim2.new(0, 120, 0, 25)
                    bill.AlwaysOnTop = true
                    bill.LightInfluence = 0
                    bill.MaxDistance = 5000
                    bill.StudsOffset = Vector3.new(0,9,0)

                    local label = Instance.new("TextLabel")
                    label.Parent = bill
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1,0,1,0)
                    label.Font = Enum.Font.Gotham
                    label.TextSize = 10
                    label.TextColor3 = Color3.new(1,1,1)
                    label.TextStrokeTransparency = 0
                    label.TextStrokeColor3 = Color3.new(0,0,0)
                    label.RichText = true
                    label.Text = plr.Name
                else
                    gui.Enabled = true
                end
            else
                if gui then gui.Enabled = false end
            end
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Distance ESP
local function UpdateDistanceESP()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local localPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local root = plr.Character.HumanoidRootPart
            local dist = math.floor((root.Position - localPos).Magnitude)

            local data = espDistanceTable[plr]
            if ESPDistanceEnabled.Value then
                if not data then
                    local bill = Instance.new("BillboardGui")
                    bill.Name = "DistanceESP"
                    bill.Adornee = root
                    bill.Parent = root
                    bill.Size = UDim2.new(0, 80, 0, 20)
                    bill.AlwaysOnTop = true
                    bill.LightInfluence = 0
                    bill.StudsOffset = Vector3.new(0, -9, 0)

                    local label = Instance.new("TextLabel")
                    label.Parent = bill
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1,0,1,0)
                    label.Font = Enum.Font.Gotham
                    label.TextSize = 10
                    label.TextColor3 = Color3.new(1,1,1)
                    label.TextStrokeTransparency = 0
                    label.TextStrokeColor3 = Color3.new(0,0,0)
                    label.RichText = true
                    label.Text = "Distance: "..dist.."m"

                    espDistanceTable[plr] = {bill = bill, label = label}
                else
                    data.label.Text = "Distance: "..dist.."m"
                    data.bill.Enabled = true
                end
            else
                if data and data.bill then
                    data.bill.Enabled = false
                end
            end
        end
    end
end

-- Loop ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(1)
        UpdateNameESP()
        UpdateDistanceESP()
    end
end)

-- Player Added / Removing
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.5)
    UpdateNameESP()
    UpdateDistanceESP()
end)

Players.PlayerRemoving:Connect(function(plr)
    local gui = plr.Character and plr.Character:FindFirstChild("NameESP")
    if gui then gui:Destroy() end
    local distData = espDistanceTable[plr]
    if distData and distData.bill then
        distData.bill:Destroy()
        espDistanceTable[plr] = nil
    end
end)

-- WindUI Toggle
EspTab:Toggle({
    Title = "ESP Name",
    Icon = "circle-check",
    Default = false,
    Callback = function(state)
        ESPNameEnabled.Value = state
    end
})

EspTab:Toggle({
    Title = "ESP Distance",
    Icon = "circle-check",
    Default = false,
    Callback = function(state)
        ESPDistanceEnabled.Value = state
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- BoolValue ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Health Bar
local ESPHealthEnabled = Instance.new("BoolValue")
ESPHealthEnabled.Name = "ESPHealthEnabled"
ESPHealthEnabled.Value = false
ESPHealthEnabled.Parent = LocalPlayer

local healthBars = {} -- ‡πÄ‡∏Å‡πá‡∏ö GUI ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Health Bar ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
local function CreateHealthBar(plr)
    if plr == LocalPlayer then return end
    if not plr.Character or not plr.Character:FindFirstChild("Humanoid") then return end
    local humanoid = plr.Character.Humanoid

    if plr.Character:FindFirstChild("HealthESP") then
        plr.Character.HealthESP:Destroy()
    end

    local bar = Instance.new("BillboardGui")
    bar.Name = "HealthESP"
    bar.Adornee = plr.Character:FindFirstChild("HumanoidRootPart") or plr.Character:FindFirstChild("Head")
    bar.Size = UDim2.new(0, 30, 0, 3) -- ‡∏Å‡∏ß‡πâ‡∏≤‡∏á 60 ‡∏™‡∏π‡∏á 6 studs
    bar.StudsOffset = Vector3.new(0, -5, 0) -- ‡∏ß‡∏≤‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß
    bar.AlwaysOnTop = true
    bar.LightInfluence = 0
    bar.Parent = plr.Character

    -- ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏µ‡∏î‡∏≥
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1,0,1,0)
    bg.Position = UDim2.new(0,0,0,0)
    bg.BackgroundColor3 = Color3.fromRGB(0,0,0)
    bg.BorderSizePixel = 0
    bg.Parent = bar

    -- Bar ‡∏´‡∏•‡∏±‡∏Å
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1,0,1,0)
    frame.Position = UDim2.new(0,0,0,0)
    frame.BackgroundColor3 = Color3.fromRGB(144,238,144) -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    frame.BorderSizePixel = 0
    frame.Parent = bg

    healthBars[plr] = {bar = bar, bg = bg, frame = frame, humanoid = humanoid}
end

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Health Bar ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if not ESPHealthEnabled.Value then
        for plr, data in pairs(healthBars) do
            data.bar.Enabled = false
        end
        return
    end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                if not healthBars[plr] then
                    CreateHealthBar(plr)
                end
                local data = healthBars[plr]
                local humanoid = data.humanoid
                local percent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                data.frame.Size = UDim2.new(percent,0,1,0)
                data.frame.Position = UDim2.new(0,0,0,0) -- ‡∏≠‡∏¢‡∏π‡πà‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤

                -- ‡∏™‡∏µ‡∏≠‡πà‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏î
                if percent > 0.5 then
                    data.frame.BackgroundColor3 = Color3.fromRGB(144,238,144) -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô
                elseif percent > 0.25 then
                    data.frame.BackgroundColor3 = Color3.fromRGB(255,255,102) -- ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á‡∏≠‡πà‡∏≠‡∏ô
                else
                    data.frame.BackgroundColor3 = Color3.fromRGB(255,102,102) -- ‡πÅ‡∏î‡∏á‡∏≠‡πà‡∏≠‡∏ô
                end
                data.bar.Enabled = true
            end
        end
    end
end)

-- ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.5)
    if ESPHealthEnabled.Value then
        CreateHealthBar(plr)
    end
end)

-- ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏≠‡∏Å
Players.PlayerRemoving:Connect(function(plr)
    if healthBars[plr] then
        healthBars[plr].bar:Destroy()
        healthBars[plr] = nil
    end
end)

-- WindUI Toggle
EspTab:Toggle({
    Title = "Health",
    Default = false,
    Callback = function(state)
        ESPHealthEnabled.Value = state
    end
})



-- // ===== ESP HIGHLIGHT ===== // --

local ESPEnabledValue = Instance.new("BoolValue")
ESPEnabledValue.Name = "ESPEnabled"
ESPEnabledValue.Value = false
ESPEnabledValue.Parent = LocalPlayer

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight
local function CreateESP(player)
    if not player.Character then return end
    if player.Character:FindFirstChild("ESP_HIGHLIGHT") then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_HIGHLIGHT"
    highlight.FillColor = Color3.fromRGB(180, 40, 255) -- ‡∏°‡πà‡∏ß‡∏á‡∏ó‡∏∂‡∏ö
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.2
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character
end

-- ‡∏•‡∏ö ESP ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î
local function RemoveESP(player)
    if player.Character and player.Character:FindFirstChild("ESP_HIGHLIGHT") then
        player.Character.ESP_HIGHLIGHT:Destroy()
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ESP ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if not ESPEnabledValue.Value then
        -- ‡∏õ‡∏¥‡∏î ESP ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏≠‡∏≠‡∏Å
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                RemoveESP(plr)
            end
        end
        return
    end

    -- ‡πÄ‡∏õ‡∏¥‡∏î ESP ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏° highlight ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            if plr.Character then
                CreateESP(plr)
            end
        end
    end
end)

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å 60 ‡∏ß‡∏¥
task.spawn(function()
    while true do
        task.wait(3)

        if ESPEnabledValue.Value then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    CreateESP(plr)
                end
            end
        end
    end
end)

-- WindUI ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î
EspTab:Toggle({
    Title = "Highlight",
    Value = ESPEnabledValue.Value,
    Callback = function(state)
        ESPEnabledValue.Value = state
        
        if not state then
            -- ‡∏õ‡∏¥‡∏î ESP ‚Üí ‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    RemoveESP(plr)
                end
            end
        end
    end
})

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î
local ESPEnabledValue = Instance.new("BoolValue")
ESPEnabledValue.Value = false
ESPEnabledValue.Name = "ESPEnabled"
ESPEnabledValue.Parent = LocalPlayer

local tracerLines = {} -- ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏™‡πâ‡∏ô tracer ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local hue = 0
local updateInterval = 1 -- ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó player list

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó tracer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local function UpdateTracers()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if not tracerLines[player] then
                local line = Drawing.new("Line")
                line.Thickness = 1
                line.Transparency = 1
                line.Color = Color3.fromHSV(hue,1,1)
                line.Visible = ESPEnabledValue.Value
                tracerLines[player] = line
            end
        end
    end

    -- ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°
    for player, line in pairs(tracerLines) do
        if not player.Parent or not player.Character then
            line:Remove()
            tracerLines[player] = nil
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏™‡πâ‡∏ô tracer ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    hue = (hue + 0.0001) % 1 -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á‡∏ä‡πâ‡∏≤‡∏°‡∏≤‡∏Å

    if not ESPEnabledValue.Value then
        for _, line in pairs(tracerLines) do
            line.Visible = false
        end
        return
    end

    for player, line in pairs(tracerLines) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local headPos = player.Character.Head.Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
            if onScreen then
                line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y) -- ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Color = Color3.fromHSV(hue,1,1)
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó list player ‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(updateInterval)
        UpdateTracers()
    end
end)

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ï‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
Players.PlayerAdded:Connect(function()
    UpdateTracers()
end)

Players.PlayerRemoving:Connect(function(player)
    if tracerLines[player] then
        tracerLines[player]:Remove()
        tracerLines[player] = nil
    end
end)

-- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏±‡∏ô
UpdateTracers()

-- WindUI ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î ESP Tracer
EspTab:Toggle({
    Title = "Tracer",
    Value = ESPEnabledValue.Value,
    Callback = function(state)
        ESPEnabledValue.Value = state
        for _, line in pairs(tracerLines) do
            line.Visible = state
        end
    end
})



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer

local ItemESP_Enabled = false

local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

local RARITY_COLORS = {
    ["Common"] = Color3.fromRGB(230, 224, 224),
    ["Uncommon"] = Color3.fromRGB(200, 230, 200),
    ["Rare"] = Color3.fromRGB(160, 200, 255),
    ["Epic"] = Color3.fromRGB(200, 160, 255),
    ["Legendary"] = Color3.fromRGB(255, 200, 120),
    ["Omega"] = Color3.fromRGB(255, 120, 120),
}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á key ‡∏Ç‡∏≠‡∏á Tool
local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return nil end

    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id") or tool:GetAttribute("WeaponId") or tool:GetAttribute("GunId")
    if itemId and itemId ~= "" then
        return "ITEMID_" .. tostring(itemId)
    end

    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureId or "NOTEX"))
        elseif part:IsA("MeshPart") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureID or "NOTEX"))
        elseif part:IsA("Decal") and part.Texture and part.Texture ~= "" then
            table.insert(partsData, "DECAL_"..part.Texture)
        end
    end

    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end

    local displayName = tool:GetAttribute("DisplayName") or tool.Name
    local toolName = tool.Name
    local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"
    local imageId = tool:GetAttribute("ImageId") or "NOIMAGE"
    return "NAME_" .. displayName .. "_" .. toolName .. "_" .. rarity .. "_" .. imageId
end

-- ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô Tool ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end

        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        if imageId and imageId ~= "" and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                pcall(function()
                    ContentProvider:PreloadAsync({imageId})
                end)
            end)
        end
    end
end

pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end
    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local key = generateUniqueKey(tool)
    return WeaponDB[key]
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local function createBillboardForPlayer(player)
    if player == LocalPlayer then return end

    local function updateESP()
        if not ItemESP_Enabled or not player.Character then return end

        local currentTools = {}
        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") and tool.Name ~= "Fists" then
                    local info = getWeaponInfo(tool)
                    if info then
                        table.insert(currentTools, info)
                    end
                end
            end
        end

        scan(player.Character)
        local backpack = player:FindFirstChild("Backpack")
        if backpack then scan(backpack) end

        if not BillboardCache[player] or not BillboardCache[player].Parent then
            -- ‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡πÉ‡∏´‡∏°‡πà
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ItemESP"
            billboard.Adornee = hrp
            billboard.Size = UDim2.new(0, 280, 0, 40)
            billboard.StudsOffset = Vector3.new(0, -6.5, 0)
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.Parent = hrp

            local container = Instance.new("Frame", billboard)
            container.Size = UDim2.new(1,0,1,0)
            container.BackgroundTransparency = 1

            BillboardCache[player] = billboard
        end

        -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Tool
        local container = BillboardCache[player]:FindFirstChildOfClass("Frame")
        if container then
            container:ClearAllChildren()
            local layout = Instance.new("UIGridLayout")
            layout.CellSize = UDim2.new(0,35,0,35)
            layout.CellPadding = UDim2.new(0,6,0,0)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            for i, info in ipairs(currentTools) do
                local img = Instance.new("ImageLabel")
                img.Parent = container
                img.Size = UDim2.new(0,35,0,35)
                img.BackgroundTransparency = 1
                img.Image = info.ImageId or "rbxassetid://7072725737"
                img.ScaleType = Enum.ScaleType.Fit
                img.LayoutOrder = i
                local color = RARITY_COLORS[info.Rarity] or Color3.fromRGB(255,255,255)
                img.ImageColor3 = color:Lerp(Color3.new(1,1,1),0.35)
            end
        end
    end

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÅ‡∏•‡∏∞‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    task.spawn(function()
        while ItemESP_Enabled and player.Parent do
            pcall(updateESP)
            task.wait(1)
        end
    end)

    -- ‡πÄ‡∏Å‡πá‡∏ö connection
    ItemESP_UpdateConnections[player] = {}
    if player.Character then
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildAdded:Connect(function()
            if ItemESP_Enabled then
                task.defer(updateESP)
            end
        end))
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildRemoved:Connect(function()
            if ItemESP_Enabled then
                task.defer(updateESP)
            end
        end))
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô (‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏´‡∏≤‡∏¢)
local function UpdateAllItemESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local hasBillboard = BillboardCache[player] and BillboardCache[player].Parent
            if ItemESP_Enabled and (not hasBillboard) then
                createBillboardForPlayer(player)
            end
        end
    end
end

-- Loop ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(1)
        UpdateAllItemESP()
    end
end)

-- Player Added/Removed
Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer and ItemESP_Enabled then
        task.wait(0.1)
        createBillboardForPlayer(p)
    end
end)
Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then
        BillboardCache[p]:Destroy()
        BillboardCache[p] = nil
    end
    if ItemESP_UpdateConnections[p] then
        for _, conn in pairs(ItemESP_UpdateConnections[p]) do
            if conn.Connected then conn:Disconnect() end
        end
        ItemESP_UpdateConnections[p] = nil
    end
end)

-- WindUI Toggle
EspTab:Toggle({
    Title = "Item",
    Icon = "circle-check",
    Value = ItemESP_Enabled,
    Callback = function(state)
        ItemESP_Enabled = state
        if state then
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LocalPlayer then
                    createBillboardForPlayer(p)
                end
            end
        else
            for p, billboard in pairs(BillboardCache) do
                if billboard then billboard:Destroy() end
            end
            BillboardCache = {}
            for player, conns in pairs(ItemESP_UpdateConnections) do
                for _, conn in pairs(conns) do
                    if conn.Connected then conn:Disconnect() end
                end
                ItemESP_UpdateConnections[player] = nil
            end
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local ItemESP_Enabled = false  -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î ESP
local ESP_Items = {}  -- ‡πÄ‡∏Å‡πá‡∏ö Highlight + Drawing ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏≠‡πÄ‡∏ó‡∏°

-- ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏ó‡πà ‡πÜ
local HIGHLIGHT_COLOR = Color3.fromRGB(200, 0, 255)
local TEXT_COLOR = Color3.fromRGB(255, 255, 255)

-- ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á DroppedItem ‡πÅ‡∏•‡∏∞ DroppedItems)
local droppedFolder = Workspace:FindFirstChild("DroppedItem") or Workspace:FindFirstChild("DroppedItems")
if not droppedFolder then
    warn("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå DroppedItem / DroppedItems")
    return
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡πÉ‡∏´‡πâ‡πÑ‡∏≠‡πÄ‡∏ó‡∏° 1 ‡∏ä‡∏¥‡πâ‡∏ô
local function createItemESP(item)
    if not ItemESP_Enabled then return end
    if ESP_Items[item] then return end  -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏ã‡πâ‡∏≥
    if item.Name == "Money" then return end  -- ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô Money
    if not item:FindFirstChild("Handle") and not item.PrimaryPart then return end

    local handle = item:FindFirstChild("Handle") or item.PrimaryPart

    -- Highlight ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á
    local highlight = Instance.new("Highlight")
    highlight.FillColor = HIGHLIGHT_COLOR
    highlight.OutlineColor = HIGHLIGHT_COLOR
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = item

    -- ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏° (Drawing Text)
    local nameText = Drawing.new("Text")
    nameText.Size = 16
    nameText.Color = TEXT_COLOR
    nameText.Center = true
    nameText.Outline = true
    nameText.Font = 2
    nameText.Visible = true
    nameText.Text = item.Name

    -- ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á (Drawing Text)
    local distanceText = Drawing.new("Text")
    distanceText.Size = 10
    distanceText.Color = TEXT_COLOR
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Font = 2
    distanceText.Visible = true

    -- ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
    ESP_Items[item] = {
        highlight = highlight,
        name = nameText,
        distance = distanceText,
        handle = handle
    }

    -- ‡∏•‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏´‡∏≤‡∏¢
    item.AncestryChanged:Connect(function()
        if not item.Parent then
            if ESP_Items[item] then
                highlight:Destroy()
                nameText:Remove()
                distanceText:Remove()
                ESP_Items[item] = nil
            end
        end
    end)
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î ESP
local function enableItemESP()
    ItemESP_Enabled = true
    -- ‡∏™‡πÅ‡∏Å‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
    for _, item in pairs(droppedFolder:GetChildren()) do
        if item:IsA("Model") or item:IsA("Tool") or item:IsA("Folder") then
            task.spawn(function()
                task.wait(0.3)
                createItemESP(item)
            end)
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏¥‡∏î ESP
local function disableItemESP()
    ItemESP_Enabled = false
    for item, data in pairs(ESP_Items) do
        if data.highlight then data.highlight:Destroy() end
        if data.name then data.name:Remove() end
        if data.distance then data.distance:Remove() end
    end
    ESP_Items = {}
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡∏∑‡πà‡∏≠ + ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.Heartbeat:Connect(function()
    if not ItemESP_Enabled then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local rootPos = player.Character.HumanoidRootPart.Position

    for item, data in pairs(ESP_Items) do
        if item and item.Parent and data.handle and data.handle.Parent then
            local worldPos = data.handle.Position + Vector3.new(0, 2, 0)
            local screenPos, onScreen = camera:WorldToViewportPoint(worldPos)

            if onScreen then
                local screen2D = Vector2.new(screenPos.X, screenPos.Y)
                local distance = math.floor((rootPos - data.handle.Position).Magnitude)

                data.name.Position = screen2D
                data.name.Visible = true

                data.distance.Position = screen2D + Vector2.new(0, 18)
                data.distance.Text = distance .. "m"
                data.distance.Visible = true
            else
                data.name.Visible = false
                data.distance.Visible = false
            end
        else
            -- ‡∏•‡∏ö‡∏ñ‡πâ‡∏≤‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏´‡∏≤‡∏¢
            if data.highlight then data.highlight:Destroy() end
            if data.name then data.name:Remove() end
            if data.distance then data.distance:Remove() end
            ESP_Items[item] = nil
        end
    end
end)

-- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å‡πÉ‡∏´‡∏°‡πà
droppedFolder.ChildAdded:Connect(function(item)
    task.wait(0.5)
    createItemESP(item)
end)

-- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á WindUI Toggle
EspTab:Toggle({
    Title = "Dropped Items",
    Value = ItemESP_Enabled,
    Callback = function(state)
        if state then
            enableItemESP()
        else
            disableItemESP()
        end
    end
})


local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer
local placeId = game.PlaceId

ServerTab:Button({
    Title = "Copy JobId",
    Desc = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏ÅID server",
    Callback = function()
        setclipboard(game.JobId)
        print("Copied JobId:", game.JobId)
    end
})

ServerTab:Divider()
local jobInput = ""
ServerTab:Input({
    Title = "JobId",
    Desc = "‡πÉ‡∏™‡πà ID ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏¢‡πâ‡∏≤‡∏¢‡πÄ‡∏Ç‡πâ‡∏≤",
    Placeholder = "",
    Callback = function(text)
        jobInput = text
    end
})

ServerTab:Button({
    Title = "Join JobId",
    Callback = function()
        if jobInput ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobInput, player)
        else
            warn("‡πÉ‡∏™‡πà JobId ‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å")
        end
    end
})

local PlaceId = 104715542330896
local TargetPlayers = 28

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = game.Players.LocalPlayer

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
local function GetServers(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100%s"):format(
        PlaceId,
        cursor and ("&cursor=" .. cursor) or ""
    )

    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    return success and result or nil
end


ServerTab:Button({
    Title = "Auto Server Hop",
    Desc = "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏ó‡∏µ‡πà‡∏Ñ‡∏ô ‡πÄ‡∏¢‡∏≠‡∏∞‡πÜ ",
    Callback = function()
        task.spawn(function()
            print("üîç ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏Ñ‡∏ô ‚â§ " .. TargetPlayers .. "...")

            while true do
                local cursor = nil
                local found = false

                repeat
                    local data = GetServers(cursor)
                    if not data then break end

                    for _, server in ipairs(data.data) do
                        local playing = server.playing or 0

                        if playing <= TargetPlayers and playing < server.maxPlayers then
                            print("üìå ‡πÄ‡∏à‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü:", server.id, " | ‡∏Ñ‡∏ô:", playing)
                            TeleportService:TeleportToPlaceInstance(PlaceId, server.id, LocalPlayer)
                            found = true
                            break
                        end
                    end

                    cursor = data.nextPageCursor
                until cursor == nil or found

                task.wait(0.2)
            end
        end)
    end
})

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

function Rejoin()
    local player = Players.LocalPlayer
    if not player then return end
    
    local placeId = game.PlaceId
    local jobId = game.JobId

    -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ rejoin ‡πÅ‡∏ö‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏î‡πâ ‡∏à‡∏∞ teleport ‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏ó‡∏ô
    local success, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
    end)

    if not success then
        warn("Rejoin ‡πÅ‡∏ö‡∏ö instance ‡πÄ‡∏î‡∏¥‡∏°‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:", err)
        TeleportService:Teleport(placeId, player)
    end
end

ServerTab:Button({
    Title = "Rejoin ",
    Desc = "‡πÄ‡∏î‡πá‡∏Å‡∏Ç‡πâ‡∏≤‡∏áegg ‡∏≠‡∏¢‡∏≤‡∏Å‡∏Å‡∏•‡∏±‡∏ö‡∏ö‡πâ‡∏≤‡∏ô",
    Callback = function()
        Rejoin()
    end
})

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local function GetServers(cursor)
    local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    if cursor then
        url = url .. "&cursor=" .. cursor
    end

    local success, response = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    if success then
        return response
    else
        warn("Error loading servers:", response)
        return nil
    end
end

function FindLowServer()
    local cursor = nil
    local lowestServer = nil

    repeat
        local servers = GetServers(cursor)
        if not servers then break end

        for _, server in ipairs(servers.data) do
            local playing = server.playing or 0

            if playing < server.maxPlayers then
                -- ‡∏´‡∏≤‡∏Ñ‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                if (not lowestServer) or (playing < lowestServer.playing) then
                    lowestServer = server
                end
            end
        end

        cursor = servers.nextPageCursor
    until cursor == nil

    if lowestServer then
        print("üîç ‡∏û‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡∏ô‡πâ‡∏≠‡∏¢:", lowestServer.id, " ‡∏Ñ‡∏ô:", lowestServer.playing)
        TeleportService:TeleportToPlaceInstance(game.PlaceId, lowestServer.id, Players.LocalPlayer)
    else
        warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á")
    end
end

ServerTab:Button({
    Title = "small Server",
    Desc = "‡∏´‡∏≤‡∏Ñ‡∏ô‡∏ô‡πâ‡∏≠‡∏¢",
    Locked = false,
    Callback = function()
        FindLowServer()
    end
})

local FPSBoostEnabled = false

local Lighting = game:GetService("Lighting")
local OriginalSky = {}
local OriginalParts = {}

-- ‡πÇ‡∏ó‡∏ô‡πÄ‡∏ó‡∏≤‡πÅ‡∏ö‡∏ö‡∏™‡∏ö‡∏≤‡∏¢‡∏ï‡∏≤
local grayColor = Color3.fromRGB(180,180,180)

-- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Sky ‡πÄ‡∏î‡∏¥‡∏°
for _, v in ipairs(Lighting:GetChildren()) do
    if v:IsA("Sky") then
        table.insert(OriginalSky, v)
    end
end

-- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á Part ‡πÄ‡∏î‡∏¥‡∏°
local function SaveOriginal(part)
    if OriginalParts[part] then return end
    OriginalParts[part] = {
        Color = part.Color,
        Material = part.Material,
        TextureID = part:IsA("MeshPart") and part.TextureID or nil
    }
end

local function BoostFPS_Enable()
    -- ‡∏•‡∏ö Sky
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("Sky") then v:Destroy() end
    end

    -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ + ‡∏•‡∏ö‡∏†‡∏≤‡∏û
    for _, obj in ipairs(workspace:GetDescendants()) do

        if obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
            obj:Destroy()

        elseif obj:IsA("BasePart") then
            SaveOriginal(obj)
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic

        elseif obj:IsA("MeshPart") then
            SaveOriginal(obj)
            obj.TextureID = ""
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic
        end
    end
end

local function BoostFPS_Disable()
    -- ‡∏Ñ‡∏∑‡∏ô Sky
    for _, sky in ipairs(OriginalSky) do
        sky.Parent = Lighting
    end

    -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á Part ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    for part, data in pairs(OriginalParts) do
        if part and part.Parent then
            part.Color = data.Color
            part.Material = data.Material
            if part:IsA("MeshPart") and data.TextureID then
                part.TextureID = data.TextureID
            end
        end
    end
end
ServerTab:Section({Title="Server Mods  :"})

ServerTab:Button({
    Title = "No sky  (Click)",
    Desc = "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î‡∏´‡∏ô‡∏≤‡∏ß ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡πâ‡∏≠‡∏ô‡πÄ‡∏°‡∏Ü‡∏ï‡∏∂‡∏á‡πÜ‚ö™",
    Callback = function()
        FPSBoostEnabled = not FPSBoostEnabled
        
        if FPSBoostEnabled then
            BoostFPS_Enable()
        else
            BoostFPS_Disable()
        end
    end
})

ServerTab:Button({
    Title = "Remove Roads",
    Desc = "‡∏•‡∏ö‡∏ñ‡∏ô‡∏ô‡∏≠‡∏≠‡∏Åüõ£Ô∏è",
    Callback = function()

        local success, mapFolder = pcall(function()
            return workspace:WaitForChild("Map", 5)
        end)

        if not success or not mapFolder then
            warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö workspace.Map")
            return
        end

        local road = mapFolder:FindFirstChild("RoadNetwork")
        if road then
            road:Destroy()
            print("‚úÖ ‡∏•‡∏ö RoadNetwork ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
        else
            warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Map.RoadNetwork")
        end
    end
})

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π DoorSystem ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function removeDoors()
    pcall(function()
        -- ‡∏•‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå DoorSystem
        if workspace:FindFirstChild("DoorSystem") then
            workspace.DoorSystem:Destroy()
        end

        -- ‡∏•‡∏π‡∏õ‡∏ó‡∏∏‡∏Å‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå‡πÉ‡∏ô workspace
        for _, obj in pairs(workspace:GetDescendants()) do
            local name = obj.Name:lower()
            local parentName = obj.Parent and obj.Parent.Name:lower() or ""
            if name:find("door") or parentName:find("door") then
                if obj:IsA("Model") then
                    obj:Destroy()
                elseif obj:IsA("BasePart") then
                    obj.CanCollide = false
                    obj.Transparency = 1
                    if obj:FindFirstChild("ClickDetector") then
                        obj.ClickDetector.MaxActivationDistance = 0
                    end
                end
            end
        end
    end)
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏° WindUI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π
ServerTab:Button({
    Title = "Remove Doors",
    Desc = "‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡∏≠‡∏≠‡∏Åüö™",
    Locked = false,
    Callback = function()
        removeDoors()  -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π
        print("‚úÖ DoorSystem & all doors removed!")
    end
})
