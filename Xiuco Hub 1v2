-- 1Ô∏è‚É£ ‡πÇ‡∏´‡∏•‡∏î WindUI ‡πÅ‡∏•‡∏∞‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≤‡∏á‡πÜ
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

-- 2Ô∏è‚É£ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
local Window = WindUI:CreateWindow({
    Title = "XIUCO HUB | BlockSpin",
    Icon = "anchor",
    Author = "My Xiuco | Pvp Paidüíµ",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Light",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "v 0.4.2",
    Icon = "arrow-big-up",
    Color = Color3.fromHex("#000000"),
    Radius = 13, -- from 0 to 13
})

-- 3Ô∏è‚É£ Tab Combat & Weapon
local CombatTab = Window:Tab({Title = "Combat", Icon = "crosshair"})
CombatTab:Section({Title="Gun :"})

local WeaponTab = Window:Tab({Title = "Weapon Mods:", Icon = "crosshair"})
WeaponTab:Section({Title="Weapon Mods :"})

local CheaterTab = Window:Tab({Title = "Cheater", Icon = "user"})
CheaterTab:Section({Title="PLAYER  :"})

local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})

local MiscTab = Window:Tab({Title = "Misc", Icon = "user"})
MiscTab:Section({Title="Misc  :"})

local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="Server Hop  :"})

-- 4Ô∏è‚É£ ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ Value ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ô‡πÄ‡∏Å‡∏°
local SilentAimEnabledValue = Instance.new("BoolValue", LocalPlayer); SilentAimEnabledValue.Name = "SilentAimEnabled"; SilentAimEnabledValue.Value = false
local AttackAntiLockEnabledValue = Instance.new("BoolValue", LocalPlayer); AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"; AttackAntiLockEnabledValue.Value = false
local MagicBulletEnabledValue = Instance.new("BoolValue", LocalPlayer); MagicBulletEnabledValue.Name = "MagicBulletEnabled"; MagicBulletEnabledValue.Value = false
local TargetPartValue = Instance.new("StringValue", LocalPlayer); TargetPartValue.Name = "TargetPart"; TargetPartValue.Value = "Head"
local FOVRadiusValue = Instance.new("NumberValue", LocalPlayer); FOVRadiusValue.Name = "FOVRadius"; FOVRadiusValue.Value = 230
local MaxLockDistanceValue = Instance.new("NumberValue", LocalPlayer); MaxLockDistanceValue.Name = "MaxLockDistance"; MaxLockDistanceValue.Value = 1000
local FireRateEnabled = Instance.new("BoolValue", LocalPlayer); FireRateEnabled.Name = "FireRateEnabled"; FireRateEnabled.Value = false

local AimModeValue = Instance.new("StringValue", LocalPlayer); AimModeValue.Name = "AimMode"; AimModeValue.Value = "Center"

local CurrentTarget
local head, aimPos
local IgnorePlayers = {}

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- 5Ô∏è‚É£ FOV Polygon (15 ‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°)
local sides = 20
local fovPolygon = {}
for i = 1, sides do
    fovPolygon[i] = Drawing.new("Line")
    fovPolygon[i].Color = Color3.fromRGB(0,255,0)
    fovPolygon[i].Thickness = 3
    fovPolygon[i].Visible = false
end

-- 6Ô∏è‚É£ Tracer Line
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.fromRGB(0,255,0)
tracerLine.Thickness = 3
tracerLine.Visible = false

-- 7Ô∏è‚É£ Target Box 45¬∞
local targetBox = Drawing.new("Quad")
targetBox.Color = Color3.fromRGB(255,255,255)
targetBox.Thickness = 1
targetBox.Visible = false

-- 8Ô∏è‚É£ Prediction
local PREDICTION_FACTOR_NORMAL = 0.165
local PREDICTION_FACTOR = PREDICTION_FACTOR_NORMAL
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")

-- 9Ô∏è‚É£ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center
    if AimModeValue.Value == "Center" then
        center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
        center = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(TargetPartValue.Value) then
            -- ‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Ñ‡∏Ñ‡∏ô‡∏ï‡∏≤‡∏¢
            local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                continue
            end

            local skip = false
            for _, name in pairs(IgnorePlayers) do
                if player.Name == name then skip = true break end
            end
            if skip then continue end

            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character[TargetPartValue.Value].Position)
            if onScreen then
                local distToScreenCenter = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                local distToPlayer = (player.Character[TargetPartValue.Value].Position - LocalPlayer.Character.Head.Position).Magnitude
                if distToScreenCenter < FOVRadiusValue.Value and distToPlayer <= MaxLockDistanceValue.Value and distToScreenCenter < shortest then
                    shortest = distToScreenCenter
                    closest = player
                end
            end
        end
    end
    return closest
end

local function PredictPosition(part)
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return part.Position end

    if AttackAntiLockEnabledValue.Value then
        local headCFrame = part.CFrame
        local forward = headCFrame.LookVector
        return part.Position + forward * PREDICTION_FACTOR * 2
    end

    local velocity = root.Velocity
    local prediction = part.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = part.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local function UpdateFireRate()
    if not FireRateEnabled.Value then return end
    local char = LocalPlayer.Character
    if not char then return end
    for _, tool in pairs(char:GetChildren()) do
        if tool:IsA("Tool") and GunLookup[tool.Name] then
            for _, val in pairs(tool:GetChildren()) do
                if val:IsA("NumberValue") and val.Name:lower():find("fire") then
                    val.Value = FireRateValue.Value
                end
            end
            if tool:FindFirstChild("FireRate") then
                tool.FireRate.Value = FireRateValue.Value
            end
        end
    end
end

LocalPlayer.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") and GunLookup[child.Name] then
        UpdateFireRate()
    end
end)

-- üîü Hook ‡∏¢‡∏¥‡∏á
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) then
            head = CurrentTarget.Character[TargetPartValue.Value]
            aimPos = PredictPosition(head)

            -- ‡∏£‡∏≠‡∏¢‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô
            local ourHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
            if ourHead then
                local startPos = ourHead.Position
                local distance = (aimPos - startPos).Magnitude
                local beam = Instance.new("Part", workspace)
                beam.Anchored = true
                beam.CanCollide = false
                beam.Material = Enum.Material.Neon
                beam.Size = Vector3.new(0.15,0.15,distance)
                beam.CFrame = CFrame.new(startPos, aimPos) * CFrame.new(0,0,-distance/2)
                beam.Color = Color3.fromRGB(255,255,255)
                game:GetService("Debris"):AddItem(beam, 1)
            end

            if MagicBulletEnabledValue.Value then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
                args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
                args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
            end
        end
    end
    return oldFire(self, unpack(args))
end)

-- 1Ô∏è‚É£1Ô∏è‚É£ RenderStepped ‡∏õ‡∏£‡∏±‡∏ö polygon, tracer, target box
RunService.RenderStepped:Connect(function()
    local center
    if AimModeValue.Value == "Center" then
        center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
        center = Vector2.new(mouseLocation.X, mouseLocation.Y)
    end

    local radius = FOVRadiusValue.Value

    if not SilentAimEnabledValue.Value then
        for i = 1, sides do fovPolygon[i].Visible = false end
        tracerLine.Visible = false
        targetBox.Visible = false
        return
    end

    -- Polygon
    local angleStep = 2*math.pi / sides
    local points = {}
    for i = 1, sides do
        local angle = angleStep * (i-1)
        points[i] = Vector2.new(center.X + math.cos(angle)*radius, center.Y + math.sin(angle)*radius)
    end
    for i = 1, sides do
        fovPolygon[i].From = points[i]
        fovPolygon[i].To = points[i % sides + 1]
        fovPolygon[i].Visible = true
    end

    -- Tracer & Target Box
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild(TargetPartValue.Value) then
        local predictedPos = PredictPosition(target.Character[TargetPartValue.Value])
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            tracerLine.From = center
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Visible = true

            local size = 15
            local diag = size/math.sqrt(2)
            local screenCorners = {
                Vector2.new(screenPos.X - diag, screenPos.Y),
                Vector2.new(screenPos.X, screenPos.Y - diag),
                Vector2.new(screenPos.X + diag, screenPos.Y),
                Vector2.new(screenPos.X, screenPos.Y + diag),
            }
            targetBox.PointA = screenCorners[1]
            targetBox.PointB = screenCorners[2]
            targetBox.PointC = screenCorners[3]
            targetBox.PointD = screenCorners[4]
            targetBox.Visible = true
        else
            tracerLine.Visible = false
            targetBox.Visible = false
        end
    else
        tracerLine.Visible = false
        targetBox.Visible = false
    end
end)

-- ======= CombatTab UI =======
CombatTab:Toggle({
    Title = "Silent Aim",
    Icon = "circle-check",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti aim",
    Icon = "circle-check",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
        PREDICTION_FACTOR = state and 0.165 or PREDICTION_FACTOR_NORMAL
    end
})

CombatTab:Slider({
    Title = "FOV :",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value)
        FOVRadiusValue.Value = value
    end
})

CombatTab:Dropdown({
    Title = "aim shoot",
    Values = {"Head","UpperTorso"},
    Value = TargetPartValue.Value,
    Callback = function(option)
        TargetPartValue.Value = option
    end
})

CombatTab:Input({
    Title = "safe Players",
    Placeholder = "‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏•‡πá‡∏≠‡∏Ñ, ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,",
    InputIcon = "shield-check",
    Callback = function(txt)
        IgnorePlayers = {}
        for inputName in string.gmatch(txt, '([^,]+)') do
            inputName = inputName:match("^%s*(.-)%s*$")
            for _, plr in ipairs(Players:GetPlayers()) do
                if string.lower(plr.Name) == string.lower(inputName) then
                    table.insert(IgnorePlayers, plr.Name)
                end
            end
        end
    end
})

CombatTab:Divider()

CombatTab:Dropdown({
    Title = "Aim Mode",
    Values = {"Center", "Mouse"},
    Value = AimModeValue.Value,
    Callback = function(option)
        AimModeValue.Value = option
    end
})

CombatTab:Slider({
    Title = "aim Distance",
    Step = 5,
    Value = {Min = 200, Max = 3000, Default = MaxLockDistanceValue.Value},
    Callback = function(value)
        MaxLockDistanceValue.Value = value
    end
})


CombatTab:Toggle({
    Title = "Magic Bullet",
    Icon = "circle-check",
    Value = MagicBulletEnabledValue.Value,
    Callback = function(state)
        MagicBulletEnabledValue.Value = state
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)

getgenv().NoRecoilEnabled = false

-- ‡πÄ‡∏Å‡πá‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô recoil ‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏¥‡∏î Recoil (‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
local function EnableNoRecoil()
    if getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = true

    -- override apply_recoil
    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
        -- ‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å original ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏î recoil 100%
    end

    -- loop ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö Recoil = 0
    antiLoop = task.spawn(function()
        while getgenv().NoRecoilEnabled do
            local char = Players.LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")
            if tool and tool:GetAttribute("Recoil") then
                tool:SetAttribute("Recoil", 0)
            end

            for _, gun in pairs(getgc(true)) do
                if typeof(gun) == "table" and rawget(gun, "instance") and gun.instance then
                    gun.instance:SetAttribute("Recoil", 0)
                end
            end

            task.wait(0.3)
        end
    end)

    print("‚úÖ No Recoil: ON")
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥ (‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
local function DisableNoRecoil()
    if not getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = false

    -- ‡∏Ñ‡∏∑‡∏ô recoil function ‡πÄ‡∏î‡∏¥‡∏°
    GunModule.apply_recoil = original_recoil

    -- ‡∏´‡∏¢‡∏∏‡∏î loop
    if antiLoop then
        task.cancel(antiLoop)
        antiLoop = nil
    end

    print("‚ùå No Recoil: OFF (‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ recoil ‡∏õ‡∏Å‡∏ï‡∏¥)")
end

-- üåü ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö UI
function ToggleNoRecoil(state)
    if state then
        EnableNoRecoil()
    else
        DisableNoRecoil()
    end
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Icon = "circle-check",
    Value = false,
    Callback = function(state)
        ToggleNoRecoil(state)
    end
})

local Players = game:GetService("Players")

getgenv().FastReloadMultiplier = 1.5    -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î
getgenv().FastReloadEnabled = false     -- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î

local reloadLoop = nil
local originalReloadTimes = {}          -- ‡πÄ‡∏Å‡πá‡∏ö reload_time ‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏∑‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤ gunModule ‡∏à‡∏≤‡∏Å tool
local function getGunModuleFromTool(tool)
    for _, v in pairs(getgc(true)) do
        if typeof(v) == "table"
            and rawget(v, "instance")
            and v.instance == tool
            and rawget(v, "reload_time") then
            return v
        end
    end
    return nil
end

-- ‡πÄ‡∏õ‡∏¥‡∏î Fast Reload
local function EnableFastReload()
    if getgenv().FastReloadEnabled then return end
    getgenv().FastReloadEnabled = true

    reloadLoop = task.spawn(function()
        while getgenv().FastReloadEnabled do
            local char = Players.LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")

            if tool then
                local gunModule = getGunModuleFromTool(tool)
                if gunModule and gunModule.reload_time then
                    
                    -- ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô
                    if not originalReloadTimes[gunModule] then
                        local originalTime = gunModule.reload_time.get and gunModule.reload_time.get() or 2.5
                        originalReloadTimes[gunModule] = originalTime
                    end

                    -- ‡∏ö‡∏µ‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
                    local newReload = originalReloadTimes[gunModule] / getgenv().FastReloadMultiplier
                    gunModule.reload_time:set(newReload)
                end
            end

            task.wait(0.2)
        end
    end)

    print("‚ö° Fast Reload: ON (x"..getgenv().FastReloadMultiplier..")")
end

-- ‡∏õ‡∏¥‡∏î Fast Reload
local function DisableFastReload()
    if not getgenv().FastReloadEnabled then return end
    getgenv().FastReloadEnabled = false

    -- Restore reload_time ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    for gunModule, originalTime in pairs(originalReloadTimes) do
        pcall(function()
            if gunModule.reload_time then
                gunModule.reload_time:set(originalTime)
            end
        end)
    end

    originalReloadTimes = {}

    if reloadLoop then
        task.cancel(reloadLoop)
        reloadLoop = nil
    end

    print("‚ùå Fast Reload: OFF (‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ reload_time ‡∏õ‡∏Å‡∏ï‡∏¥)")
end

WeaponTab:Toggle({
    Title = "Fast Reload",
    Icon = "circle-check",
    Value = false,
    Callback = function(state)
        ToggleFastReload(state)
    end
})



WeaponTab:Section({Title="auto hit :"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
getgenv().HitAuraEnabled = false

-- ‡∏´‡∏≤ CounterTable ‡∏à‡∏≤‡∏Å getgc
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

local SendRemote
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    SendRemote = Remotes:WaitForChild("Send", 5)
end)

-- NetSend
local function NetSend(...)
    if not CounterTable or not CounterTable.event or not SendRemote then
        return
    end
    local args = {...}
    CounterTable.event = (CounterTable.event or 0) + 1
    pcall(function()
        SendRemote:FireServer(CounterTable.event, unpack(args))
    end)
end

-- getActiveTool
local function getActiveTool()
    local char = player.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then
            return obj
        end
    end
    return nil
end

-- getPlayersInRange
local function getPlayersInRange(radius)
    local inRange = {}
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

-- AttackNearby
local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = player.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            NetSend("melee_attack", tool, {target}, lookAtCFrame, 0.75)
        end
    end
end

-- Auto Loop
local autoLoop
local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

-- üåü ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Toggle (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å UI)
function ToggleHitAura(state)
    if state then
        getgenv().HitAuraEnabled = true
        StartHitAura()
        print("‚úÖ Hit Aura: ON")
    else
        StopHitAura()
        print("‚ùå Hit Aura: OFF")
    end
end

 WeaponTab:Toggle({
     Title = "Hit Aura",
     Icon = "circle-check",
     Default = false,
     Callback = function(state)
         ToggleHitAura(state)
     end
 })

etService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

local AutoSprintLoop
local OriginalSprintUpdate
local Send

-- Setup Remotes
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    if Remotes then
        Send = Remotes:WaitForChild("Send", 5)
    end
end)

local function NetSend(action, state)
    if Send then
        pcall(function()
            Send:FireServer(action, state)
        end)
    end
end

local function EnableInfiniteStamina()
    local success, SprintModule = pcall(function()
        return require(ReplicatedStorage.Modules.Game.Sprint)
    end)
    if not success or not SprintModule then
        warn("‚ùå SprintModule ‡πÑ‡∏°‡πà‡∏û‡∏ö!")
        return false
    end

    local consume_stamina = SprintModule.consume_stamina
    local sprintData = getupvalue(consume_stamina, 2)
    if not sprintData or not sprintData.sprint_bar then
        warn("‚ùå SprintBar ‡πÑ‡∏°‡πà‡∏û‡∏ö!")
        return false
    end

    local SprintBar = sprintData.sprint_bar
    OriginalSprintUpdate = SprintBar.update

    SprintBar.update = function(...)
        return OriginalSprintUpdate(function()
            return 1 -- Stamina ‡πÄ‡∏ï‡πá‡∏°‡πÄ‡∏™‡∏°‡∏≠
        end)
    end

    AutoSprintLoop = task.spawn(function()
        while getgenv().InfiniteStaminaEnabled do
            pcall(function()
                NetSend("set_sprinting_1", true)
                task.wait(0.5)
                NetSend("set_sprinting_1", false)
            end)
            task.wait(0.1)
        end
        NetSend("set_sprinting_1", false)
    end)

    print("‚úÖ Infinite Stamina ‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß! üèÉ‚Äç‚ôÇÔ∏èüí®")
    return true
end

local function DisableInfiniteStamina()
    getgenv().InfiniteStaminaEnabled = false

    if AutoSprintLoop then
        task.cancel(AutoSprintLoop)
        AutoSprintLoop = nil
    end

    NetSend("set_sprinting_1", false)

    -- Restore Original
    local success, SprintModule = pcall(function()
        return require(ReplicatedStorage.Modules.Game.Sprint)
    end)
    if success and SprintModule then
        local consume_stamina = SprintModule.consume_stamina
        local sprintData = getupvalue(consume_stamina, 2)
        if sprintData and sprintData.sprint_bar and OriginalSprintUpdate then
            sprintData.sprint_bar.update = OriginalSprintUpdate
            OriginalSprintUpdate = nil
        end
    end

    print("‚ùå Infinite Stamina ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß!")
end

-- ======= WindUI Toggle =======
CheaterTab:Toggle({
    Title = "Infinite Stamina",
    Icon = "circle-check", -- ‡πÉ‡∏™‡πà‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    Value = getgenv().InfiniteStaminaEnabled,
    Callback = function(state)
        getgenv().InfiniteStaminaEnabled = state
        if state then
            EnableInfiniteStamina()
        else
            DisableInfiniteStamina()
        end
    end
})


-- ========================
-- Snap / Dig
-- ========================
CheaterTab:Section({Title="Snap PC key [ Z ]"})
local isRunning = false
local function SnapQuick()
    if isRunning then return end
    isRunning = true
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then isRunning=false return end
    hum.Sit = true
    local origY = hrp.Position.Y
    local offset = math.abs(SnapHeightOffset)
    if SnapDirection == "Down" then offset = -offset end
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if hrp and hrp.Parent then
            hrp.CFrame = hrp.CFrame:Lerp(CFrame.new(hrp.Position.X, origY+offset, hrp.Position.Z),0.8)
        end
    end)
    task.wait(SnapDuration)
    if conn then conn:Disconnect() conn=nil end
    hum.Sit=false
    isRunning=false
end

CheaterTab:Button({
    Title="Snap Click",
    Locked=false,
    Callback=function() SnapQuick() end
})

CheaterTab:Slider({
    Title="Snap Depth",
    Step=1,
    Value={Min=1,Max=50,Default=math.abs(SnapHeightOffset)},
    Callback=function(val)
        SnapHeightOffset=(SnapDirection=="Down" and -1 or 1)*val
    end
})

CheaterTab:Dropdown({
    Title="Snap Direction",
    Values={"Down","Up"},
    Value=SnapDirection,
    Callback=function(opt)
        SnapDirection=opt
        SnapHeightOffset=(opt=="Down" and -1 or 1)*math.abs(SnapHeightOffset)
    end
})

UserInputService.InputBegan:Connect(function(input,gpe)
    if gpe then return end
    if input.KeyCode==Enum.KeyCode.Z then SnapQuick() end
end)

= player.Character
    local head = character and character:FindFirstChild("Head")
    if not head then return end

    -- BillboardGui
    local bill = Instance.new("BillboardGui")
    bill.Name = "ESP_Name"
    bill.Adornee = head
    bill.Size = UDim2.new(0, 200, 0, 30)
    bill.StudsOffset = Vector3.new(0, 8, 0) -- ‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß
    bill.AlwaysOnTop = true
    bill.MaxDistance = 10000
    bill.Parent = head

    -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á TextLabel ‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß (‡∏Ç‡∏≠‡∏ö‡∏î‡∏≥)
    local function CreateOutlineLabel(offsetX, offsetY)
        local lbl = Instance.new("TextLabel")
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.GothamBold
        lbl.TextSize = 6
        lbl.TextColor3 = Color3.fromRGB(0, 0, 0) -- ‡∏Ç‡∏≠‡∏ö‡∏î‡∏≥
        lbl.TextStrokeTransparency = 1
        lbl.Position = UDim2.new(0, offsetX, 0, offsetY)
        lbl.Size = UDim2.new(1, 0, 1, 0)
        lbl.Text = player.Name
        lbl.Parent = bill
        return lbl
    end

    -- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏ö 8 ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
    local offsets = {
        Vector2.new(-1, -1), Vector2.new(0, -1), Vector2.new(1, -1),
        Vector2.new(-1, 0),                  Vector2.new(1, 0),
        Vector2.new(-1, 1),  Vector2.new(0, 1),  Vector2.new(1, 1)
    }
    for _, offset in pairs(offsets) do
        CreateOutlineLabel(offset.X, offset.Y)
    end

    -- TextLabel ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
    local mainLabel = Instance.new("TextLabel")
    mainLabel.BackgroundTransparency = 1
    mainLabel.Font = Enum.Font.GothamBold
    mainLabel.TextSize = 6
    mainLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    mainLabel.TextStrokeTransparency = 1
    mainLabel.Size = UDim2.new(1, 0, 1, 0)
    mainLabel.Text = player.Name
    mainLabel.Parent = bill

    ESP_Objects[player] = bill
end

local function RemoveESP(player)
    if ESP_Objects[player] then
        ESP_Objects[player]:Destroy()
        ESP_Objects[player] = nil
    end
end

local function DisableESP()
    for player, gui in pairs(ESP_Objects) do
        gui:Destroy()
    end
    ESP_Objects = {}
end

local function UpdateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if not ESP_Objects[player] and player.Character and player.Character:FindFirstChild("Head") then
            CreateESP(player)
        end
    end

    for player, gui in pairs(ESP_Objects) do
        if not player.Parent or not player.Character or not player.Character:FindFirstChild("Head") then
            RemoveESP(player)
        end
    end
end

-- ====== UI Toggle ======
EspTab:Toggle({
    Title = "Name",
    Icon = "circle-check",
    Value = ESP_Enabled,
    Callback = function(state)
        ESP_Enabled = state
        if state then
            UpdateESP()
        else
            DisableESP()
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if ESP_Enabled then
        UpdateESP()
    end
end)

-- ========================
-- ESP Health (Fix ‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡∏´‡∏≤‡∏¢)
-- ========================
local ESPHealthEnabled = false
local HealthESP_Objects = {}

local nearSize = UDim2.new(10, 1, 0, 1)
local farSize  = UDim2.new(70, 1, 0, 1)
local nearDistance = 300
local farDistance = 299
local maxDistance = 10000

local function SetBillboardSize(bill, distance)
    if distance <= nearDistance then
        bill.Size = nearSize
    elseif distance >= farDistance and distance <= maxDistance then
        bill.Size = farSize
    else
        bill.Size = UDim2.new(0, 110, 0, 12)
    end
end

local function CreateHealthESP(player)
    if player == LocalPlayer then return end

    -- ‡∏•‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≠‡∏ô
    if HealthESP_Objects[player] then
        HealthESP_Objects[player].Billboard:Destroy()
        HealthESP_Objects[player] = nil
    end

    local char = player.Character
    local head = char and char:FindFirstChild("Head")
    local humanoid = char and char:FindFirstChild("Humanoid")
    if not head or not humanoid then return end

    local bill = Instance.new("BillboardGui")
    bill.Name = "HealthESP"
    bill.Adornee = head
    bill.AlwaysOnTop = true
    bill.MaxDistance = 10000
    bill.Size = nearSize
    bill.StudsOffset = Vector3.new(0, -3, 0)
    bill.Parent = head

    local bg = Instance.new("Frame")
    bg.BackgroundColor3 = Color3.new(0,0,0)
    bg.BorderSizePixel = 0
    bg.Size = UDim2.new(1, 2, 1, 2)
    bg.Position = UDim2.new(0, -1, 0, -1)
    bg.Parent = bill

    local bar = Instance.new("Frame")
    bar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    bar.BorderSizePixel = 0
    bar.Size = UDim2.new(1, 0, 1, 0)
    bar.Parent = bill

    HealthESP_Objects[player] = {
        Billboard = bill,
        Bar = bar,
        Humanoid = humanoid
    }
end

local function SafeUpdateHealth(player, data)
    local char = player.Character
    if not char then return end

    local head = char:FindFirstChild("Head")
    if not head then
        CreateHealthESP(player)
        return
    end

    -- ‡∏ñ‡πâ‡∏≤ GUI ‡∏´‡∏≤‡∏¢ ‚Üí ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    if not data.Billboard or not data.Billboard.Parent then
        CreateHealthESP(player)
        return
    end

    local humanoid = data.Humanoid
    if not humanoid or humanoid.Parent == nil then
        CreateHealthESP(player)
        return
    end

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏•‡∏∑‡∏≠‡∏î
    local hp = math.clamp(humanoid.Health, 0, humanoid.MaxHealth)
    local percent = hp / humanoid.MaxHealth

    -- ‡∏™‡∏µ‡πÄ‡∏•‡∏∑‡∏≠‡∏î
    if percent > 0.5 then
        data.Bar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    elseif percent > 0.1 then
        data.Bar.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    else
        data.Bar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    end

    data.Bar.Size = UDim2.new(percent, 0, 1, 0)

    -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ñ‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞
    local camPos = workspace.CurrentCamera.CFrame.Position
    local distance = (camPos - head.Position).Magnitude
    SetBillboardSize(data.Billboard, distance)
end

local function MaintainHealthESP()
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            if not HealthESP_Objects[p] then
                CreateHealthESP(p)
            end
        end
    end
end

RunService.RenderStepped:Connect(function()
    if not ESPHealthEnabled then return end

    MaintainHealthESP()

    for player, data in pairs(HealthESP_Objects) do
        SafeUpdateHealth(player, data)
    end
end)

EspTab:Toggle({
    Title = "Health",
    Icon = "circle-check",
    Value = ESPHealthEnabled,
    Callback = function(state)
        ESPHealthEnabled = state
        if not state then
            for p, obj in pairs(HealthESP_Objects) do
                obj.Billboard:Destroy()
            end
            HealthESP_Objects = {}
        end
    end
})


local ESP_DistanceEnabled = false
local ESP_DistanceObjects = {}

local function CreateESPDistance(player)
    if player == LocalPlayer then return end

    local head = player.Character and player.Character:FindFirstChild("Head")
    if not head then return end

    -- ‡∏•‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏ö‡∏±‡∏Ñ
    if ESP_DistanceObjects[player] then
        ESP_DistanceObjects[player].Bill:Destroy()
        ESP_DistanceObjects[player] = nil
    end

    -- BillboardGui ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    local bill = Instance.new("BillboardGui")
    bill.Name = "ESP_Distance"
    bill.Adornee = head
    bill.Size = UDim2.new(0, 13, 0, 9)
    bill.StudsOffset = Vector3.new(0, -9, 0)
    bill.AlwaysOnTop = true
    bill.Parent = head

    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.TextSize = 7
    label.TextColor3 = Color3.new(1,1,1)
    label.TextStrokeColor3 = Color3.new(0,0,0)
    label.TextStrokeTransparency = 0
    label.Text = ""
    label.Size = UDim2.new(1,0,1,0)
    label.TextScaled = true
    label.TextWrapped = false
    label.Parent = bill

    ESP_DistanceObjects[player] = {Bill = bill, Label = label}
end

local function SafeUpdateESPDistance(player, data)
    local char = player.Character
    if not char then return end

    local head = char:FindFirstChild("Head")
    if not head then
        -- ‡∏ñ‡πâ‡∏≤‡∏´‡∏±‡∏ß‡∏´‡∏≤‡∏¢ ‚Üí ‡∏£‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
        CreateESPDistance(player)
        return
    end

    if not data.Bill or not data.Bill.Parent then
        -- ‡∏ñ‡πâ‡∏≤‡∏õ‡πâ‡∏≤‡∏¢‡∏´‡∏≤‡∏¢ ‚Üí ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        CreateESPDistance(player)
        return
    end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local lpChar = LocalPlayer.Character
    local lpHRP = lpChar and lpChar:FindFirstChild("HumanoidRootPart")

    if hrp and lpHRP then
        local dist = math.floor((hrp.Position - lpHRP.Position).Magnitude)
        data.Label.Text = "studs : " .. dist .. "m"
    end
end

local function MaintainESPDistance()
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            if not ESP_DistanceObjects[p] then
                CreateESPDistance(p)
            end
        end
    end
end

RunService.RenderStepped:Connect(function()
    if not ESP_DistanceEnabled then return end

    MaintainESPDistance()

    for player, data in pairs(ESP_DistanceObjects) do
        SafeUpdateESPDistance(player, data)
    end
end)

EspTab:Toggle({
    Title = "ESP Distance",
    Icon = "circle-check",
    Value = ESP_DistanceEnabled,
    Callback = function(state)
        ESP_DistanceEnabled = state
        if not state then
            for p, obj in pairs(ESP_DistanceObjects) do
                obj.Bill:Destroy()
            end
            ESP_DistanceObjects = {}
        end
    end
})

-- ========================
-- ESP Highlight (‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå)
-- ========================

local ESPHighlightEnabled = false
local ESPHighlightObjects = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight
local function CreateHighlight(player)
    if player == LocalPlayer then return end
    if ESPHighlightObjects[player] then return end

    local character = player.Character
    if not character then return end

local highlight = Instance.new("Highlight")
highlight.Adornee = character
highlight.FillColor = Color3.fromRGB(255, 140, 0) -- ‡∏™‡∏µ‡∏™‡πâ‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
highlight.FillTransparency = 0 -- ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™ ‚Üí ‡∏™‡∏µ‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
highlight.OutlineColor = Color3.fromRGB(255, 100, 0) -- ‡∏Ç‡∏≠‡∏ö‡∏™‡πâ‡∏°‡πÄ‡∏Ç‡πâ‡∏°
highlight.OutlineTransparency = 0 -- ‡∏Ç‡∏≠‡∏ö‡πÑ‡∏°‡πà‡πÇ‡∏õ‡∏£‡πà‡∏á
highlight.Parent = workspace

    ESPHighlightObjects[player] = highlight
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö Highlight
local function RemoveHighlight(player)
    if ESPHighlightObjects[player] then
        ESPHighlightObjects[player]:Destroy()
        ESPHighlightObjects[player] = nil
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Highlight ‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
local function UpdateHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if ESPHighlightEnabled then
            if not ESPHighlightObjects[player] then
                CreateHighlight(player)
            end
        else
            RemoveHighlight(player)
        end
    end

    -- ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡πÄ‡∏Å‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
    for player, highlight in pairs(ESPHighlightObjects) do
        if not player.Parent or not player.Character then
            RemoveHighlight(player)
        end
    end
end

-- Event player ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
Players.PlayerAdded:Connect(function(player)
    task.wait(0.5)
    if ESPHighlightEnabled then
        CreateHighlight(player)
    end
end)

-- Event player ‡∏≠‡∏≠‡∏Å
Players.PlayerRemoving:Connect(function(player)
    RemoveHighlight(player)
end)

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if ESPHighlightEnabled then
        UpdateHighlights()
    end
end)

-- ====== UI Toggle ======
EspTab:Toggle({
    Title = "Highlight",
    Icon = "circle-check",
    Value = ESPHighlightEnabled,
    Callback = function(state)
        ESPHighlightEnabled = state
        if not state then
            -- ‡∏õ‡∏¥‡∏î‡∏•‡∏ö‡∏ó‡∏∏‡∏Å Highlight
            for player, _ in pairs(ESPHighlightObjects) do
                RemoveHighlight(player)
            end
        else
            UpdateHighlights()
        end
    end
})

local ESPEnabled = false
local ESPBoxes = {}
local MIN_SIZE = Vector2.new(3, 6)
local MAX_SIZE = Vector2.new(30, 70)

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box 2D
local function createESPBox()
    local box = Drawing.new("Square")
    box.Thickness = 0.5
    box.Filled = false
    box.Color = Color3.new(1,1,1)
    box.Visible = false
    return box
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Box 2D
local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if hrp and humanoid then
                if not ESPBoxes[player] then
                    ESPBoxes[player] = createESPBox()
                end
                local box = ESPBoxes[player]

                local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                    local scale = math.clamp(50 / distance, 0, 1)
                    box.Size = Vector2.new(
                        math.clamp(MAX_SIZE.X * scale, MIN_SIZE.X, MAX_SIZE.X),
                        math.clamp(MAX_SIZE.Y * scale, MIN_SIZE.Y, MAX_SIZE.Y)
                    )

                    box.Position = Vector2.new(screenPos.X - box.Size.X/2, screenPos.Y - box.Size.Y/2)
                    box.Visible = ESPEnabled
                else
                    box.Visible = false
                end
            elseif ESPBoxes[player] then
                ESPBoxes[player].Visible = false
            end
        elseif ESPBoxes[player] then
            ESPBoxes[player].Visible = false
        end
    end
end

EspTab:Toggle({
    Title = "Box",
    Icon = "circle-check",
    Value = ESPEnabled,
    Callback = function(state)
        ESPEnabled = state
        if not state then
            for _, box in pairs(ESPBoxes) do
                box:Remove()
            end
            ESPBoxes = {}
        end
    end
})

RunService.RenderStepped:Connect(function()
    if ESPEnabled then
        updateESP()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if ESPBoxes[player] then
        ESPBoxes[player]:Remove()
        ESPBoxes[player] = nil
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer

local ItemESP_Enabled = false

local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

-- ‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏Å‡∏¥‡∏ô‡∏õ‡∏∑‡∏ô‡πÑ‡∏î‡πâ‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô)
local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return nil end

    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id") or tool:GetAttribute("WeaponId") or tool:GetAttribute("GunId")  -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
    if itemId and itemId ~= "" then
        return "ITEMID_" .. tostring(itemId)
    end

    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" and part.MeshId ~= "rbxassetid://" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureId or "NOTEX"))
        elseif part:IsA("MeshPart") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureID or "NOTEX"))
        elseif part:IsA("Decal") and part.Texture and part.Texture ~= "" then
            table.insert(partsData, "DECAL_"..part.Texture)
        end
    end

    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end

    local displayName = tool:GetAttribute("DisplayName") or tool.Name
    local toolName = tool.Name
    local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Unknown"
    local imageId = tool:GetAttribute("ImageId") or "NOIMAGE"
    return "NAME_" .. displayName .. "_" .. toolName .. "_" .. rarity .. "_" .. imageId
end

-- ‡∏™‡πà‡∏ß‡∏ô registerItems ‡πÅ‡∏•‡∏∞ getWeaponInfo ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end

        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        if imageId and imageId ~= "" and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                pcall(function()
                    ContentProvider:PreloadAsync({imageId})
                end)
            end)
        end
    end
end

pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end
    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local key = generateUniqueKey(tool)
    return WeaponDB[key]
end

-- ‡∏™‡πà‡∏ß‡∏ô createBillboardForPlayer ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
local function createBillboardForPlayer(player)
    if player == LocalPlayer or BillboardCache[player] then return end

    local billboard, container, layout
    local connections = {}

    local function updateESP()
        if not ItemESP_Enabled or not billboard.Parent then return end

        local currentTools = {}
        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") and tool.Name ~= "Fists" then
                    local info = getWeaponInfo(tool)
                    if info then
                        table.insert(currentTools, info)
                    end
                end
            end
        end

        local char = player.Character
        if char then
            scan(char)
            local backpack = player:FindFirstChild("Backpack")
            if backpack then scan(backpack) end
        end

        container:ClearAllChildren()

        layout = Instance.new("UIGridLayout")
        layout.CellSize = UDim2.new(0, 35, 0, 35)
        layout.CellPadding = UDim2.new(0, 6, 0, 0)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        for i, info in ipairs(currentTools) do
            local img = Instance.new("ImageLabel")
            img.Parent = container
            img.Size = UDim2.new(0, 35, 0, 35)
            img.BackgroundTransparency = 1
            img.Image = info.ImageId or "rbxassetid://7072725737"
            img.ScaleType = Enum.ScaleType.Fit
            img.LayoutOrder = i

            local color = RARITY_COLORS[info.Rarity] or Color3.fromRGB(255, 255, 255)
            img.ImageColor3 = color:Lerp(Color3.new(1,1,1), 0.35)
        end
    end

    local function setupBillboard()
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if BillboardCache[player] then
            BillboardCache[player]:Destroy()
        end

        for _, conn in pairs(connections) do
            if conn.Connected then conn:Disconnect() end
        end
        connections = {}

        billboard = Instance.new("BillboardGui")
        billboard.Name = "ItemESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 280, 0, 40)
        billboard.StudsOffset = Vector3.new(0, -6.5, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.Parent = hrp

        container = Instance.new("Frame", billboard)
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        BillboardCache[player] = billboard

        updateESP()

        -- ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            table.insert(connections, backpack.ChildAdded:Connect(updateESP))
            table.insert(connections, backpack.ChildRemoved:Connect(updateESP))
        end

        table.insert(connections, char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then task.defer(updateESP) end
        end))
        table.insert(connections, char.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then task.defer(updateESP) end
        end))
    end

    if player.Character then task.spawn(setupBillboard) end

    table.insert(connections, player.CharacterAdded:Connect(function()
        task.wait(1)
        setupBillboard()
    end))

    ItemESP_UpdateConnections[player] = connections
end

-- ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        createBillboardForPlayer(p)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        createBillboardForPlayer(p)
    end
end)

Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then
        BillboardCache[p]:Destroy()
        BillboardCache[p] = nil
    end
    if ItemESP_UpdateConnections[p] then
        for _, conn in pairs(ItemESP_UpdateConnections[p]) do
            if conn.Connected then conn:Disconnect() end
        end
        ItemESP_UpdateConnections[p] = nil
    end
end)

-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏Ñ‡πà‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ: ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å 0.1 ‡∏ß‡∏¥ (‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î)
RunService.Heartbeat:Connect(function()
    if not ItemESP_Enabled then return end
    task.wait(0.1)
    for _, p in Players:GetPlayers() do
        if p ~= LocalPlayer and BillboardCache[p] then
            pcall(function()
                local updateFunc = BillboardCache[p].Parent.Parent.updateESP
                if updateFunc then updateFunc() end
            end)
        end
    end
end)

-- ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î WindUI
EspTab:Toggle({
    Title = "Item",
    Icon = "circle-check",
    Value = ItemESP_Enabled,
    Callback = function(state)
        ItemESP_Enabled = state
        if state then
            -- ‡πÄ‡∏õ‡∏¥‡∏î: ‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LocalPlayer then createBillboardForPlayer(p) end
            end
        else
            -- ‡∏õ‡∏¥‡∏î: ‡∏•‡∏ö Billboard ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            for p, billboard in pairs(BillboardCache) do
                if billboard then billboard:Destroy() end
            end
            BillboardCache = {}
            for player, conns in pairs(ItemESP_UpdateConnections) do
                for _, conn in pairs(conns) do
                    if conn.Connected then conn:Disconnect() end
                end
                ItemESP_UpdateConnections[player] = nil
            end
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local lp = Players.LocalPlayer
local DroppedItems = Workspace:WaitForChild("DroppedItems")
local espTable = {}
getgenv().DroppedItemESPEnabled = true -- Toggle ‡∏î‡πâ‡∏ß‡∏¢ RightShift

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏™‡∏µ‡∏à‡∏≤‡∏Å Highlight/Glow ‡∏Ç‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°
local function getGlowColor(item)
    local hl = item:FindFirstChildWhichIsA("Highlight")
    if hl then
        return hl.OutlineColor
    end
    return Color3.new(1,1,1) -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≤‡∏ß
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ESP
local function createESP(item)
    if item.Name == "Money" then return end -- ‡∏Ç‡πâ‡∏≤‡∏° Money

    local mainPart = item:FindFirstChild("Handle") or item.PrimaryPart or item:FindFirstChildOfClass("Part")
    if not mainPart then return end

    local box = Drawing.new("Square")
    box.Size = Vector2.new(0,0)
    box.Position = Vector2.new(0,0)
    box.Thickness = 0.2
    box.Filled = false
    box.Visible = false

    local nameText = Drawing.new("Text")
    nameText.Size = 10
    nameText.Center = true
    nameText.Outline = true
    nameText.Font = 1
    nameText.Visible = false
    nameText.Text = item.Name

    local distText = Drawing.new("Text")
    distText.Size = 10
    distText.Center = false
    distText.Outline = true
    distText.Font = 1
    distText.Visible = false

    espTable[item] = {box = box, name = nameText, dist = distText}
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏•‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
local function worldToScreen(pos)
    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(pos)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ESP
local function updateESP()
    if not getgenv().DroppedItemESPEnabled then
        for _, drawings in pairs(espTable) do
            drawings.box.Visible = false
            drawings.name.Visible = false
            drawings.dist.Visible = false
        end
        return
    end

    local char = lp.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    local rootPos = char.HumanoidRootPart.Position

    for item, drawings in pairs(espTable) do
        if not item or not item.Parent then
            drawings.box:Remove()
            drawings.name:Remove()
            drawings.dist:Remove()
            espTable[item] = nil
            continue
        end

        local mainPart = item:FindFirstChild("Handle") or item.PrimaryPart or item:FindFirstChildOfClass("Part")
        if not mainPart then
            drawings.box.Visible = false
            drawings.name.Visible = false
            drawings.dist.Visible = false
            continue
        end

        local screenPos, onScreen = worldToScreen(mainPart.Position)
        if not onScreen then
            drawings.box.Visible = false
            drawings.name.Visible = false
            drawings.dist.Visible = false
            continue
        end

        local distance = math.floor((rootPos - mainPart.Position).Magnitude)
        local itemSize = math.clamp(1500 / distance, 8, 60)

        -- ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏à‡∏≤‡∏Å Glow/Highlight
        local color = getGlowColor(item)

        -- Box
        drawings.box.Size = Vector2.new(itemSize, itemSize * 1.2)
        drawings.box.Position = screenPos - drawings.box.Size / 2
        drawings.box.Color = color
        drawings.box.Visible = true

        -- Name
        local namePos = screenPos - Vector2.new(0, drawings.box.Size.Y / 2 + 25)
        drawings.name.Position = namePos
        drawings.name.Color = color
        drawings.name.Visible = true

        -- Distance
        drawings.dist.Text = tostring(distance) .. "m"
        drawings.dist.Position = namePos + Vector2.new(drawings.name.TextBounds.X / 2 + 8, 0)
        drawings.dist.Color = color
        drawings.dist.Visible = true
    end
end

-- Toggle ESP ‡∏î‡πâ‡∏ß‡∏¢ RightShift
game:GetService("UserInputService").InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        getgenv().DroppedItemESPEnabled = not getgenv().DroppedItemESPEnabled
        print("DroppedItem ESP: " .. (getgenv().DroppedItemESPEnabled and "ON" or "OFF"))
    end
end)

-- Loop ‡∏´‡∏•‡∏±‡∏Å
RunService.Heartbeat:Connect(updateESP)

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡πÉ‡∏´‡πâ‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
for _, item in pairs(DroppedItems:GetChildren()) do
    createESP(item)
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡πÉ‡∏´‡∏°‡πà
DroppedItems.ChildAdded:Connect(function(item)
    createESP(item)
end)

EspTab:Toggle({
    Title = "Dropped Item",
    Icon = "circle-check",
    Default = true,
    Callback = function(state)
        getgenv().DroppedItemESPEnabled = state

        -- ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î -> ‡∏ã‡πà‡∏≠‡∏ô ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        if not state then
            for item, drawings in pairs(espTable) do
                drawings.box.Visible = false
                drawings.name.Visible = false
                drawings.dist.Visible = false
            end
        end
        
        print("Dropped Item ESP:", state and "ON" or "OFF")
    end
})


getgenv().SkipCrateEnabled = false


local ReplicatedStorage = game:GetService("ReplicatedStorage")


local SendRemote
local connection

-- TrySkipCrate Function (copy ‡∏à‡∏≤‡∏Å‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö 100%)
local function TrySkipCrate()
    local success, CrateController = pcall(function()
        return require(ReplicatedStorage.Modules.Game.CrateSystem.Crate)
    end)
    if success and CrateController and CrateController.spinning and CrateController.spinning.get() then
        CrateController.skip_spin()
        print("‚úÖ Skip Crate Spin!")
    end
end

-- Setup Auto Skip (listen Send.OnClientEvent)
local function SetupAutoSkip()
    if connection then
        connection:Disconnect()
    end
    
    pcall(function()
        connection = SendRemote.OnClientEvent:Connect(function(...)
            if getgenv().SkipCrateEnabled then
                task.spawn(TrySkipCrate)
            end
        end)
    end)
end

-- Enable / Disable Functions
local function EnableSkipCrate()
    getgenv().SkipCrateEnabled = true
    SetupAutoSkip()
    TrySkipCrate()  -- Skip ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    print("ü™£ SkipCrate: ON | Auto Skip Spin ‡∏ó‡∏∏‡∏Å Crate!")
end

local function DisableSkipCrate()
    getgenv().SkipCrateEnabled = false
    if connection then
        connection:Disconnect()
    end
    print("ü™£ SkipCrate: OFF")
end

-- Setup Remotes
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    SendRemote = Remotes:WaitForChild("Send", 10)
end)

-- ======= WindUI Toggle =======
MiscTab:Toggle({
    Title = "Skip Crate",
    Icon = "circle-check",  -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    Value = getgenv().SkipCrateEnabled,
    Callback = function(state)
        getgenv().SkipCrateEnabled = state
        if state then
            EnableSkipCrate()
        else
            DisableSkipCrate()
        end
    end
})

MiscTab:Section({Title="Claim Quest all :"})

-- Info
if SendRemote then
    print("‚úÖ BlockSpin SkipCrate Loaded! | Toggle ‡∏ú‡πà‡∏≤‡∏ô UI ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢")
else
    warn("‚ùå Remotes.Send ‡πÑ‡∏°‡πà‡∏û‡∏ö! ‡∏£‡∏≠‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà")
end

-- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ WindUI ‡πÅ‡∏•‡∏∞ Tab ‡∏ó‡∏µ‡πà‡∏ä‡∏∑‡πà‡∏≠ CheaterTab ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- ‡∏´‡∏≤ CounterTable ‡∏à‡∏≤‡∏Å getgc
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

-- Net.get Function
local Net = {}
local function NetGet(...)
    if not CounterTable or not CounterTable.func then
        warn("‚ùå CounterTable ‡πÑ‡∏°‡πà‡∏û‡∏ö!")
        return
    end
    local args = {...}
    CounterTable.func = (CounterTable.func or 0) + 1
    local success, result = pcall(function()
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))
    end)
    if not success then
        warn("[NetGet Error]", result)
    end
    return result
end
function Net.get(...)
    return NetGet(...)
end

-- Claim All Function
local function ClaimAllQuests()
    local success, questFrame = pcall(function()
        return player:WaitForChild("PlayerGui"):WaitForChild("Quests"):WaitForChild("QuestsHolder"):WaitForChild("QuestsScrollingFrame")
    end)
    if not success or not questFrame then
        warn("‚ùå Quest GUI ‡πÑ‡∏°‡πà‡∏û‡∏ö! (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î Quests)")
        return 0
    end
    
    local claimed = 0
    for _, child in ipairs(questFrame:GetChildren()) do
        if (child:IsA("Frame") or child:IsA("TextButton") or child:IsA("ImageButton")) and child.Name ~= "" then
            pcall(function()
                Net.get("claim_quest", child.Name)
            end)
            claimed = claimed + 1
            task.wait(0.2)
        end
    end
    return claimed
end

CheaterTab:Button({
    Title = "Claim All Quests",
    Desc = "‡∏Å‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠ Claim Quest ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î üéØ",
    Locked = false,
    Callback = function()
        local claimed = ClaimAllQuests()  -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô ClaimAllQuests
        if claimed > 0 then
            print("‚úÖ Claimed", claimed, "Quests!")
        else
            print("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ Quest ‡πÉ‡∏´‡πâ Claim")
        end
    end
})

local PlaceId = 104715542330896
local TargetPlayers = 28
local HopperEnabled = false  -- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î

local function StartServerHopper()
    if HopperEnabled then
        print("üîÑ Server Hopper ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß...")
        return
    end

    HopperEnabled = true
    print("üöÄ Server Hopper ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ô ‚â§ 28...")

    task.spawn(function()
        while HopperEnabled do
            local cursor = nil
            local found = false

            repeat
                local success, data = pcall(function()
                    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100%s"):format(
                        PlaceId,
                        cursor and ("&cursor="..cursor) or ""
                    )
                    return game.HttpService:JSONDecode(game:HttpGet(url))
                end)

                if not success or not data or not data.data then
                    task.wait(1)
                    break
                end

                for _, server in ipairs(data.data) do
                    if not HopperEnabled then return end  -- ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏≤‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ

                    local playing = server.playing or 0

                    if playing <= TargetPlayers and playing < server.maxPlayers then
                        print("‚úÖ ‡πÄ‡∏à‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏õ‡πä‡∏∞! ‡∏Ñ‡∏ô:", playing.."/"..server.maxPlayers, "| ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ID:", server.id)
                        HopperEnabled = false  -- ‡∏õ‡∏¥‡∏î auto ‡∏Å‡πà‡∏≠‡∏ô teleport
                        task.wait(1)
                        game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceId, server.id, game.Players.LocalPlayer)
                        found = true
                        break
                    end
                end

                cursor = data.nextPageCursor

            until not cursor or found or not HopperEnabled

            if not found and HopperEnabled then
                task.wait(0.3)  -- ‡∏´‡∏≤‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å
            end
        end
    end)
end

local function StopServerHopper()
    HopperEnabled = false
    print("‚õî Server Hopper ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß")
end

ServerTab:Button({
    Title = "Server big Hop",
    Desc = "‡∏Å‡∏î‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏Ñ‡∏ô‡πÄ‡∏¢‡∏≠‡∏∞ üöÄ",
    Default = false,
    Callback = function(state)
        if state then
            StartServerHopper()
            Notify({
                Title = "Server big Hop",
                Description = "‡∏Å‡∏î‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏Ñ‡∏ô‡πÄ‡∏¢‡∏≠‡∏∞",
                Duration = 6
            })
        else
            StopServerHopper()
            Notify({
                Title = "Server Hopper",
                Description = "‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
                Duration = 4
            })
        end
    end
})

local FPSBoostEnabled = false

local Lighting = game:GetService("Lighting")
local OriginalSky = {}
local OriginalParts = {}

-- ‡πÇ‡∏ó‡∏ô‡πÄ‡∏ó‡∏≤‡πÅ‡∏ö‡∏ö‡∏™‡∏ö‡∏≤‡∏¢‡∏ï‡∏≤
local grayColor = Color3.fromRGB(180,180,180)

-- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Sky ‡πÄ‡∏î‡∏¥‡∏°
for _, v in ipairs(Lighting:GetChildren()) do
    if v:IsA("Sky") then
        table.insert(OriginalSky, v)
    end
end

-- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á Part ‡πÄ‡∏î‡∏¥‡∏°
local function SaveOriginal(part)
    if OriginalParts[part] then return end
    OriginalParts[part] = {
        Color = part.Color,
        Material = part.Material,
        TextureID = part:IsA("MeshPart") and part.TextureID or nil
    }
end

local function BoostFPS_Enable()
    -- ‡∏•‡∏ö Sky
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("Sky") then v:Destroy() end
    end

    -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ + ‡∏•‡∏ö‡∏†‡∏≤‡∏û
    for _, obj in ipairs(workspace:GetDescendants()) do

        if obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
            obj:Destroy()

        elseif obj:IsA("BasePart") then
            SaveOriginal(obj)
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic

        elseif obj:IsA("MeshPart") then
            SaveOriginal(obj)
            obj.TextureID = ""
            obj.Color = grayColor
            obj.Material = Enum.Material.SmoothPlastic
        end
    end
end

local function BoostFPS_Disable()
    -- ‡∏Ñ‡∏∑‡∏ô Sky
    for _, sky in ipairs(OriginalSky) do
        sky.Parent = Lighting
    end

    -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á Part ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    for part, data in pairs(OriginalParts) do
        if part and part.Parent then
            part.Color = data.Color
            part.Material = data.Material
            if part:IsA("MeshPart") and data.TextureID then
                part.TextureID = data.TextureID
            end
        end
    end
end
ServerTab:Section({Title="Server Mods  :"})

ServerTab:Button({
    Title = "No sky  (Click)",
    Desc = "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î‡∏´‡∏ô‡∏≤‡∏ß ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡πâ‡∏≠‡∏ô‡πÄ‡∏°‡∏Ü‡∏ï‡∏∂‡∏á‡πÜ‚ö™",
    Callback = function()
        FPSBoostEnabled = not FPSBoostEnabled
        
        if FPSBoostEnabled then
            BoostFPS_Enable()
        else
            BoostFPS_Disable()
        end
    end
})

ServerTab:Button({
    Title = "Remove Roads",
    Desc = "‡∏•‡∏ö‡∏ñ‡∏ô‡∏ô‡∏≠‡∏≠‡∏Åüõ£Ô∏è",
    Callback = function()

        local success, mapFolder = pcall(function()
            return workspace:WaitForChild("Map", 5)
        end)

        if not success or not mapFolder then
            warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö workspace.Map")
            return
        end

        local road = mapFolder:FindFirstChild("RoadNetwork")
        if road then
            road:Destroy()
            print("‚úÖ ‡∏•‡∏ö RoadNetwork ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
        else
            warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Map.RoadNetwork")
        end
    end
})

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π DoorSystem ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function removeDoors()
    pcall(function()
        -- ‡∏•‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå DoorSystem
        if workspace:FindFirstChild("DoorSystem") then
            workspace.DoorSystem:Destroy()
        end

        -- ‡∏•‡∏π‡∏õ‡∏ó‡∏∏‡∏Å‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå‡πÉ‡∏ô workspace
        for _, obj in pairs(workspace:GetDescendants()) do
            local name = obj.Name:lower()
            local parentName = obj.Parent and obj.Parent.Name:lower() or ""
            if name:find("door") or parentName:find("door") then
                if obj:IsA("Model") then
                    obj:Destroy()
                elseif obj:IsA("BasePart") then
                    obj.CanCollide = false
                    obj.Transparency = 1
                    if obj:FindFirstChild("ClickDetector") then
                        obj.ClickDetector.MaxActivationDistance = 0
                    end
                end
            end
        end
    end)
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏° WindUI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π
ServerTab:Button({
    Title = "Remove Doors",
    Desc = "‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡∏≠‡∏≠‡∏Åüö™",
    Locked = false,
    Callback = function()
        removeDoors()  -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ï‡∏π
        print("‚úÖ DoorSystem & all doors removed!")
    end
})
