-- 1Ô∏è‚É£ ‡πÇ‡∏´‡∏•‡∏î WindUI ‡πÅ‡∏•‡∏∞‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≤‡∏á‡πÜ
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

-- 2Ô∏è‚É£ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
local Window = WindUI:CreateWindow({
    Title = "üëëXIUCO HUB PVP  v.0.6 | paid‚öîÔ∏è",
    Icon = "rbxassetid://107970969112343",
    Author = "My Xiuco | Discord XIUCO ‚Ä¢ https://discord.gg/sYjE3Kf3t",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Light",
    Transparent = true,
    Resizable = true,
})

Window:EditOpenButton({
    Title = "XIUCO HUB | Paid",
    Icon = "cat",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("910AC7"), Color3.fromHex("910AC7")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true
})

-- 3Ô∏è‚É£ Tab Main
local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})


local Players = game:GetService("Players")  
local RunService = game:GetService("RunService")  
local Workspace = game:GetService("Workspace")  
local LocalPlayer = Players.LocalPlayer  
local camera = Workspace.CurrentCamera  

-- Config  
local BOX_COLOR = Color3.fromRGB(255, 255, 255)  
local BOX_THICKNESS = 2  
local SCALE_MULTIPLIER = 1  

-- Table ‡πÄ‡∏Å‡πá‡∏ö ESP ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô  
local espPlayers = {}  

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤ (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)  
local CurrentTarget = nil  -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ  

-- ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏•‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠  
local function worldToViewport(pos)  
    local screen, onScreen = camera:WorldToViewportPoint(pos)  
    return Vector2.new(screen.X, screen.Y), onScreen  
end  

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box ESP  
local function createBoxESP(plr)  
    if espPlayers[plr] or plr == LocalPlayer then return end  

    local lines = {}  
    for i = 1, 12 do  
        local line = Drawing.new("Line")  
        line.Visible = false  
        line.Color = BOX_COLOR  
        line.Thickness = BOX_THICKNESS  
        line.Transparency = 1  
        lines[i] = line  
    end  

    local connection = RunService.RenderStepped:Connect(function()  
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then  
            for _, line in ipairs(lines) do line.Visible = false end  
            return  
        end  

        local root = plr.Character.HumanoidRootPart  
        local rootPos = root.Position  
        local scale = root.Size.Y * SCALE_MULTIPLIER  

        local corners = {  
            Vector3.new(-1,  2, -1), Vector3.new( 1,  2, -1), Vector3.new( 1,  2,  1), Vector3.new(-1,  2,  1),  
            Vector3.new(-1, -2, -1), Vector3.new( 1, -2, -1), Vector3.new( 1, -2,  1), Vector3.new(-1, -2,  1)  
        }  

        local screenCorners = {}  
        local allOnScreen = true  

        for i, offset in ipairs(corners) do  
            local worldPos = rootPos + (root.CFrame:VectorToWorldSpace(offset * scale))  
            local screenPos, onScreen = worldToViewport(worldPos)  
            screenCorners[i] = screenPos  
            if not onScreen then allOnScreen = false end  
        end  

        if not allOnScreen then  
            for _, line in ipairs(lines) do line.Visible = false end  
            return  
        end  

        -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô  
        local color = (CurrentTarget == plr) and Color3.fromRGB(255,0,0) or BOX_COLOR  

        local edges = {  
            {1,2},{2,3},{3,4},{4,1},  
            {5,6},{6,7},{7,8},{8,5},  
            {1,5},{2,6},{3,7},{4,8}  
        }  

        for i, edge in ipairs(edges) do  
            local line = lines[i]  
            line.From = screenCorners[edge[1]]  
            line.To = screenCorners[edge[2]]  
            line.Color = color  -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏™‡∏µ  
            line.Visible = true  
        end  
    end)  

    espPlayers[plr] = {connection = connection, lines = lines}  
end  

-- ‡∏•‡∏ö Box ESP  
local function removeBoxESP(plr)  
    if espPlayers[plr] then  
        if espPlayers[plr].connection then espPlayers[plr].connection:Disconnect() end  
        for _, line in ipairs(espPlayers[plr].lines) do line:Remove() end  
        espPlayers[plr] = nil  
    end  
end  

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î  
local function enableAllESP()  
    for _, plr in pairs(Players:GetPlayers()) do  
        if plr ~= LocalPlayer then createBoxESP(plr) end  
    end  
end  

-- ‡∏•‡∏ö ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î  
local function disableAllESP()  
    for plr, _ in pairs(espPlayers) do  
        removeBoxESP(plr)  
    end  
end  

-- Player Added/Removing  
Players.PlayerAdded:Connect(function(plr)  
    task.wait(1)  
    if _G.ESPEnabled then createBoxESP(plr) end  
end)  
Players.PlayerRemoving:Connect(removeBoxESP)  

-- WindUi Toggle  
EspTab:Toggle({  
    Title = "Box",  
    Icon = "eye",  
    Default = false,  
    Callback = function(state)  
        _G.ESPEnabled = state  
        if state then  
            enableAllESP()  
            print("‚úÖ ESP Box: ON")  
        else  
            disableAllESP()  
            print("‚ùå ESP Box: OFF")  
        end  
    end  
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- BoolValue ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ESP
local ESPNameEnabled = Instance.new("BoolValue")
ESPNameEnabled.Name = "ESPNameEnabled"
ESPNameEnabled.Value = false
ESPNameEnabled.Parent = LocalPlayer

local ESPDistanceEnabled = Instance.new("BoolValue")
ESPDistanceEnabled.Name = "ESPDistanceEnabled"
ESPDistanceEnabled.Value = false
ESPDistanceEnabled.Parent = LocalPlayer

local espDistanceTable = {} -- ‡πÄ‡∏Å‡πá‡∏ö GUI ‡∏£‡∏∞‡∏¢‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó ESP Name
local function UpdateNameESP()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            local head = plr.Character.Head
            local gui = head:FindFirstChild("NameESP")
            if ESPNameEnabled.Value then
                if not gui then
                    local bill = Instance.new("BillboardGui")
                    bill.Name = "NameESP"
                    bill.Adornee = head
                    bill.Parent = head
                    bill.Size = UDim2.new(0, 120, 0, 25)
                    bill.AlwaysOnTop = true
                    bill.LightInfluence = 0
                    bill.MaxDistance = 5000
                    bill.StudsOffset = Vector3.new(0,9,0)

                    local label = Instance.new("TextLabel")
                    label.Parent = bill
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1,0,1,0)
                    label.Font = Enum.Font.Gotham
                    label.TextSize = 10
                    label.TextColor3 = Color3.new(1,1,1)
                    label.TextStrokeTransparency = 0
                    label.TextStrokeColor3 = Color3.new(0,0,0)
                    label.RichText = true
                    label.Text = plr.Name
                else
                    gui.Enabled = true
                end
            else
                if gui then gui.Enabled = false end
            end
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Distance ESP
local function UpdateDistanceESP()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local localPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local root = plr.Character.HumanoidRootPart
            local dist = math.floor((root.Position - localPos).Magnitude)

            local data = espDistanceTable[plr]
            if ESPDistanceEnabled.Value then
                if not data then
                    local bill = Instance.new("BillboardGui")
                    bill.Name = "DistanceESP"
                    bill.Adornee = root
                    bill.Parent = root
                    bill.Size = UDim2.new(0, 80, 0, 20)
                    bill.AlwaysOnTop = true
                    bill.LightInfluence = 0
                    bill.StudsOffset = Vector3.new(0, -9, 0)

                    local label = Instance.new("TextLabel")
                    label.Parent = bill
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1,0,1,0)
                    label.Font = Enum.Font.Gotham
                    label.TextSize = 10
                    label.TextColor3 = Color3.new(1,1,1)
                    label.TextStrokeTransparency = 0
                    label.TextStrokeColor3 = Color3.new(0,0,0)
                    label.RichText = true
                    label.Text = "Distance: "..dist.."m"

                    espDistanceTable[plr] = {bill = bill, label = label}
                else
                    data.label.Text = "Distance: "..dist.."m"
                    data.bill.Enabled = true
                end
            else
                if data and data.bill then
                    data.bill.Enabled = false
                end
            end
        end
    end
end

-- Loop ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(1)
        UpdateNameESP()
        UpdateDistanceESP()
    end
end)

-- Player Added / Removing
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.5)
    UpdateNameESP()
    UpdateDistanceESP()
end)

Players.PlayerRemoving:Connect(function(plr)
    local gui = plr.Character and plr.Character:FindFirstChild("NameESP")
    if gui then gui:Destroy() end
    local distData = espDistanceTable[plr]
    if distData and distData.bill then
        distData.bill:Destroy()
        espDistanceTable[plr] = nil
    end
end)

-- WindUI Toggle
EspTab:Toggle({
    Title = "ESP Name",
    Icon = "circle-check",
    Default = false,
    Callback = function(state)
        ESPNameEnabled.Value = state
    end
})

EspTab:Toggle({
    Title = "ESP Distance",
    Icon = "circle-check",
    Default = false,
    Callback = function(state)
        ESPDistanceEnabled.Value = state
    end
})




local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- BoolValue ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Health Bar
local ESPHealthEnabled = Instance.new("BoolValue")
ESPHealthEnabled.Name = "ESPHealthEnabled"
ESPHealthEnabled.Value = false
ESPHealthEnabled.Parent = LocalPlayer

local healthBars = {} -- ‡πÄ‡∏Å‡πá‡∏ö GUI ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Health Bar ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
local function CreateHealthBar(plr)
    if plr == LocalPlayer then return end
    if not plr.Character or not plr.Character:FindFirstChild("Humanoid") then return end
    local humanoid = plr.Character.Humanoid

    if plr.Character:FindFirstChild("HealthESP") then
        plr.Character.HealthESP:Destroy()
    end

    local bar = Instance.new("BillboardGui")
    bar.Name = "HealthESP"
    bar.Adornee = plr.Character:FindFirstChild("HumanoidRootPart") or plr.Character:FindFirstChild("Head")
    bar.Size = UDim2.new(0, 30, 0, 3) -- ‡∏Å‡∏ß‡πâ‡∏≤‡∏á 60 ‡∏™‡∏π‡∏á 6 studs
    bar.StudsOffset = Vector3.new(0, -5, 0) -- ‡∏ß‡∏≤‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß
    bar.AlwaysOnTop = true
    bar.LightInfluence = 0
    bar.Parent = plr.Character

    -- ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏µ‡∏î‡∏≥
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1,0,1,0)
    bg.Position = UDim2.new(0,0,0,0)
    bg.BackgroundColor3 = Color3.fromRGB(0,0,0)
    bg.BorderSizePixel = 0
    bg.Parent = bar

    -- Bar ‡∏´‡∏•‡∏±‡∏Å
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1,0,1,0)
    frame.Position = UDim2.new(0,0,0,0)
    frame.BackgroundColor3 = Color3.fromRGB(144,238,144) -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    frame.BorderSizePixel = 0
    frame.Parent = bg

    healthBars[plr] = {bar = bar, bg = bg, frame = frame, humanoid = humanoid}
end

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Health Bar ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if not ESPHealthEnabled.Value then
        for plr, data in pairs(healthBars) do
            data.bar.Enabled = false
        end
        return
    end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            if plr.Character and plr.Character:FindFirstChild("Humanoid") then
                if not healthBars[plr] then
                    CreateHealthBar(plr)
                end
                local data = healthBars[plr]
                local humanoid = data.humanoid
                local percent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                data.frame.Size = UDim2.new(percent,0,1,0)
                data.frame.Position = UDim2.new(0,0,0,0) -- ‡∏≠‡∏¢‡∏π‡πà‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤

                -- ‡∏™‡∏µ‡∏≠‡πà‡∏≠‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏î
                if percent > 0.5 then
                    data.frame.BackgroundColor3 = Color3.fromRGB(144,238,144) -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô
                elseif percent > 0.25 then
                    data.frame.BackgroundColor3 = Color3.fromRGB(255,255,102) -- ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á‡∏≠‡πà‡∏≠‡∏ô
                else
                    data.frame.BackgroundColor3 = Color3.fromRGB(255,102,102) -- ‡πÅ‡∏î‡∏á‡∏≠‡πà‡∏≠‡∏ô
                end
                data.bar.Enabled = true
            end
        end
    end
end)

-- ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà
Players.PlayerAdded:Connect(function(plr)
    task.wait(0.5)
    if ESPHealthEnabled.Value then
        CreateHealthBar(plr)
    end
end)

-- ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏≠‡∏Å
Players.PlayerRemoving:Connect(function(plr)
    if healthBars[plr] then
        healthBars[plr].bar:Destroy()
        healthBars[plr] = nil
    end
end)

-- WindUI Toggle
EspTab:Toggle({
    Title = "Health",
    Default = false,
    Callback = function(state)
        ESPHealthEnabled.Value = state
    end
})

local ESPEnabledValue = Instance.new("BoolValue")
ESPEnabledValue.Name = "ESPEnabled"
ESPEnabledValue.Value = false
ESPEnabledValue.Parent = LocalPlayer

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight
local function CreateESP(player)
    if not player.Character then return end
    if player.Character:FindFirstChild("ESP_HIGHLIGHT") then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_HIGHLIGHT"
    highlight.FillColor = Color3.fromRGB(180, 40, 255) -- ‡∏°‡πà‡∏ß‡∏á‡∏ó‡∏∂‡∏ö
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.2
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character
end

-- ‡∏•‡∏ö ESP ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î
local function RemoveESP(player)
    if player.Character and player.Character:FindFirstChild("ESP_HIGHLIGHT") then
        player.Character.ESP_HIGHLIGHT:Destroy()
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ESP ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if not ESPEnabledValue.Value then
        -- ‡∏õ‡∏¥‡∏î ESP ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏≠‡∏≠‡∏Å
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                RemoveESP(plr)
            end
        end
        return
    end

    -- ‡πÄ‡∏õ‡∏¥‡∏î ESP ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏° highlight ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            if plr.Character then
                CreateESP(plr)
            end
        end
    end
end)

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å 60 ‡∏ß‡∏¥
task.spawn(function()
    while true do
        task.wait(3)

        if ESPEnabledValue.Value then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    CreateESP(plr)
                end
            end
        end
    end
end)

-- WindUI ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î
EspTab:Toggle({
    Title = "Highlight",
    Value = ESPEnabledValue.Value,
    Callback = function(state)
        ESPEnabledValue.Value = state
        
        if not state then
            -- ‡∏õ‡∏¥‡∏î ESP ‚Üí ‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer then
                    RemoveESP(plr)
                end
            end
        end
    end
})

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î
local ESPEnabledValue = Instance.new("BoolValue")
ESPEnabledValue.Value = false
ESPEnabledValue.Name = "ESPEnabled"
ESPEnabledValue.Parent = LocalPlayer

local tracerLines = {} -- ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏™‡πâ‡∏ô tracer ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local hue = 0
local updateInterval = 1 -- ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó player list

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó tracer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local function UpdateTracers()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if not tracerLines[player] then
                local line = Drawing.new("Line")
                line.Thickness = 1
                line.Transparency = 1
                line.Color = Color3.fromHSV(hue,1,1)
                line.Visible = ESPEnabledValue.Value
                tracerLines[player] = line
            end
        end
    end

    -- ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°
    for player, line in pairs(tracerLines) do
        if not player.Parent or not player.Character then
            line:Remove()
            tracerLines[player] = nil
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏™‡πâ‡∏ô tracer ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    hue = (hue + 0.0001) % 1 -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á‡∏ä‡πâ‡∏≤‡∏°‡∏≤‡∏Å

    if not ESPEnabledValue.Value then
        for _, line in pairs(tracerLines) do
            line.Visible = false
        end
        return
    end

    for player, line in pairs(tracerLines) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local headPos = player.Character.Head.Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
            if onScreen then
                line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y) -- ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Color = Color3.fromHSV(hue,1,1)
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó list player ‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(updateInterval)
        UpdateTracers()
    end
end)

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ï‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
Players.PlayerAdded:Connect(function()
    UpdateTracers()
end)

Players.PlayerRemoving:Connect(function(player)
    if tracerLines[player] then
        tracerLines[player]:Remove()
        tracerLines[player] = nil
    end
end)

-- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏±‡∏ô
UpdateTracers()

-- WindUI ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î ESP Tracer
EspTab:Toggle({
    Title = "Tracer",
    Value = ESPEnabledValue.Value,
    Callback = function(state)
        ESPEnabledValue.Value = state
       , for _, line in pairs(tracerLines) do
            line.Visible = state
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- Config
local BOX_COLOR = Color3.fromRGB(255, 255, 255)
local BOX_THICKNESS = 2
local SCALE_MULTIPLIER = 1

-- Table ‡πÄ‡∏Å‡πá‡∏ö ESP ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô
local espPlayers = {}

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤ tracerLine
local CurrentTarget = nil
local tracerLine = Drawing.new("Line") -- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ tracerLine ‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß
tracerLine.Visible = false

-- ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏•‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
local function worldToViewport(pos)
    local screen, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(screen.X, screen.Y), onScreen
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box ESP
local function createBoxESP(plr)
    if espPlayers[plr] or plr == LocalPlayer then return end

    local lines = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = BOX_COLOR
        line.Thickness = BOX_THICKNESS
        line.Transparency = 1
        lines[i] = line
    end

    local connection = RunService.RenderStepped:Connect(function()
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        local root = plr.Character.HumanoidRootPart
        local rootPos = root.Position
        local scale = root.Size.Y * SCALE_MULTIPLIER

        local corners = {
            Vector3.new(-1,  2, -1), Vector3.new( 1,  2, -1), Vector3.new( 1,  2,  1), Vector3.new(-1,  2,  1),
            Vector3.new(-1, -2, -1), Vector3.new( 1, -2, -1), Vector3.new( 1, -2,  1), Vector3.new(-1, -2,  1)
        }

        local screenCorners = {}
        local allOnScreen = true

        for i, offset in ipairs(corners) do
            local worldPos = rootPos + (root.CFrame:VectorToWorldSpace(offset * scale))
            local screenPos, onScreen = worldToViewport(worldPos)
            screenCorners[i] = screenPos
            if not onScreen then allOnScreen = false end
        end

        if not allOnScreen then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢ tracerLine
        local color = (CurrentTarget == plr) and Color3.fromRGB(255,0,0) or BOX_COLOR

        local edges = {
            {1,2},{2,3},{3,4},{4,1},
            {5,6},{6,7},{7,8},{8,5},
            {1,5},{2,6},{3,7},{4,8}
        }

        for i, edge in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[edge[1]]
            line.To = screenCorners[edge[2]]
            line.Color = color
            line.Visible = true
        end
    end)

    espPlayers[plr] = {connection = connection, lines = lines}
end

-- ‡∏•‡∏ö Box ESP
local function removeBoxESP(plr)
    if espPlayers[plr] then
        if espPlayers[plr].connection then espPlayers[plr].connection:Disconnect() end
        for _, line in ipairs(espPlayers[plr].lines) do line:Remove() end
        espPlayers[plr] = nil
    end
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function enableAllESP()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then createBoxESP(plr) end
    end
end

-- ‡∏•‡∏ö ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function disableAllESP()
    for plr, _ in pairs(espPlayers) do
        removeBoxESP(plr)
    end
end

-- Player Added/Removing
Players.PlayerAdded:Connect(function(plr)
    task.wait(1)
    if _G.ESPEnabled then createBoxESP(plr) end
end)
Players.PlayerRemoving:Connect(removeBoxESP)

-- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
_G.ESPEnabled = false

-- Toggle ESP
EspTab:Toggle({
    Title = "Box",
    Value = _G.ESPEnabled,  -- ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏à‡∏£‡∏¥‡∏á
    Callback = function(state)
        _G.ESPEnabled = state
        if state then
            enableAllESP()
            print("‚úÖ ESP Box: ON")
        else
            disableAllESP()
            print("‚ùå ESP Box: OFF")
        end
    end
})

-- ‡πÇ‡∏´‡∏•‡∏î WindUI
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
local Window = WindUI:CreateWindow({
    Title = "Kaiju Hub | Pvp Paid üíµ",
    Icon = "gitlab",
    Author = "My Kaiju | BlockSpinüî´",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "v0.0.3",
    Icon = "cloud",
    Color = Color3.fromHex("#2889F7"),
    Radius = 13,
})

-- ‡πÅ‡∏ó‡πá‡∏ö Combat
local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Value = false
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 150
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Value = 1000
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"
TargetPartValue.Parent = LocalPlayer

local AttackAntiLockEnabledValue = Instance.new("BoolValue")
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false
AttackAntiLockEnabledValue.Parent = LocalPlayer

local IgnorePlayers = {}
local CurrentTarget, head, aimPos
local hue = 0
local lastPositions = {}

-- ‡∏õ‡∏∑‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
local GunNames = {"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9","Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 1
tracerLine.Visible = false

-- ====================
-- ‡∏Ñ‡∏≤‡∏î‡πÄ‡∏î‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
-- ====================
local PREDICTION_FACTOR = 0.165
local PREDICTION_DISTANCE = 6 -- ‡∏£‡∏∞‡∏¢‡∏∞‡∏Ñ‡∏≤‡∏î‡πÄ‡∏î‡∏≤ 6 studs

local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

local function AntiLockPrediction(part)
    if not part or not part.Parent then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    local humanoid = part.Parent:FindFirstChild("Humanoid")
    if not humanoid or not root then return part.Position end

    local headPos = part.Position + Vector3.new(0, (part:IsA("BasePart") and part.Size.Y or 1)/2, 0)

    if AttackAntiLockEnabledValue.Value then
        local velocity = root.Velocity
        local speed = velocity.Magnitude

        if speed >= 15 then
            -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô 15 ‡∏Ñ‡∏≤‡∏î‡πÄ‡∏î‡∏≤‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏ï‡πà‡∏£‡∏∞‡∏¢‡∏∞ 6
            local direction = velocity.Unit
            return headPos + direction * PREDICTION_DISTANCE
        else
            -- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤‡∏´‡∏ô‡πâ‡∏≤ ‡∏´‡∏•‡∏±‡∏á
            local lastPos = lastPositions[part.Parent] or root.Position
            local movement = root.Position - lastPos
            lastPositions[part.Parent] = root.Position

            local direction = Vector3.new(0,0,0)
            if movement.Magnitude > 0.05 then
                direction = movement.Unit
            else
                direction = part.CFrame.LookVector
            end

            return headPos + direction * PREDICTION_DISTANCE
        end
    else
        return PredictPosition(part)
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Ignore
local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

-- ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏Å‡∏•‡πâ FOV
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ñ‡∏∑‡∏≠‡∏õ‡∏∑‡∏ô
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏Å‡∏≥‡πÅ‡∏û‡∏á
local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

-- Hook ‡∏¢‡∏¥‡∏á
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = AntiLockPrediction(part)

            if MagicBulletValue.Value and (part and part.Parent and IsBehindWall(part)) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.15,0.15,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.fromHSV(math.random(),1,1)
            game:GetService("Debris"):AddItem(beam, 1)
        end
    end
    return oldFire(self, unpack(args))
end)

-- Render FOV + Tracer
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1)

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    CurrentTarget = target -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°‡∏ï‡∏≤‡∏° tracerLine

    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromHSV(hue, 1, 1)
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

-- UI Controls
CombatTab:Toggle({
    Title = "Silent Aim",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
    end
})

CombatTab:Slider({
    Title = "FOV :",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value) FOVRadiusValue.Value = value end
})

CombatTab:Slider({
    Title = "Lock Distance :",
    Step = 25,
    Value = {Min = 50, Max = 1000, Default = LockDistanceValue.Value},
    Callback = function(value) LockDistanceValue.Value = value end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

CombatTab:Toggle({
    Title = "Magic Bullet",
    Value = MagicBulletValue.Value,
    Callback = function(state) MagicBulletValue.Value = state end
})

CombatTab:Input({
    Title = "Safe Players",
    Placeholder = "‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Ñ, ‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ,",
    InputIcon = "shield-check",
    Callback = function(txt)
        IgnorePlayers = {}
        for inputName in string.gmatch(txt, '([^,]+)') do
            inputName = inputName:match("^%s*(.-)%s*$")
            table.insert(IgnorePlayers, inputName)
        end
    end
})







local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, LocalPlayer, ReplicatedStorage = game:GetService("Players"), game.Players.LocalPlayer, game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
local Window = WindUI:CreateWindow({
    Title = "Kaiju Hub | Pvp Paid üíµ",
    Icon = "gitlab",
    Author = "My Kaiju | BlockSpinüî´",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "v0.0.4 AutoUpdate",
    Icon = "cloud",
    Color = Color3.fromHex("#2889F7"),
    Radius = 13,
})

local WeaponTab = Window:Tab({Title = "WEAPON MODS:", Icon = "crosshair"})
WeaponTab:Section({Title="Gun Mods :"})

-- Fire Rate
local FireRateValue = Instance.new("NumberValue")
FireRateValue.Name = "FireRateValue"
FireRateValue.Value = 1200
FireRateValue.Parent = LocalPlayer

WeaponTab:Slider({
    Title = "Fire Rate",
    Step = 1,
    Value = {Min = 1, Max = 3000, Default = FireRateValue.Value},
    Callback = function(value)
        FireRateValue.Value = value
    end
})

-- ‡πÄ‡∏Å‡πá‡∏ö Tool ‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
local updatedTools = {}

local function UpdateToolFireRate(tool)
    if not tool then return end
    if updatedTools[tool] then return end -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Ñ‡∏¢‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥
    updatedTools[tool] = true

    for _, v in pairs(getgc(true)) do
        if typeof(v) == "table" and rawget(v, "states") then
            local s = v.states
            if s.instance == tool then
                if s.fire_rate and s.fire_rate.set then
                    s.fire_rate:set(FireRateValue.Value)
                    print("‚úÖ Fire Rate updated for Tool:", tool.Name)
                end
            end
        end
    end
end

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö Tool ‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≠‡∏ô‡∏ñ‡∏∑‡∏≠
LocalPlayer.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        UpdateToolFireRate(child)
    end
end)

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Tool ‡∏ó‡∏µ‡πà‡∏ñ‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≠‡∏ô‡πÇ‡∏´‡∏•‡∏î
task.spawn(function()
    local char = LocalPlayer.Character
    if char then
        for _, tool in pairs(char:GetChildren()) do
            if tool:IsA("Tool") then
                UpdateToolFireRate(tool)
            end
        end
    end
end)

-- No Recoil
local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)
getgenv().NoRecoilEnabled = false
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

local function EnableNoRecoil()
    if getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = true

    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
    end

    antiLoop = task.spawn(function()
        while getgenv().NoRecoilEnabled do
            local char = LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")
            if tool and tool:GetAttribute("Recoil") then
                tool:SetAttribute("Recoil", 0)
            end
            for _, gun in pairs(getgc(true)) do
                if typeof(gun) == "table" and rawget(gun, "instance") and gun.instance then
                    gun.instance:SetAttribute("Recoil", 0)
                end
            end
            task.wait(0.3)
        end
    end)
    print("‚úÖ No Recoil: ON")
end

local function DisableNoRecoil()
    if not getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = false
    GunModule.apply_recoil = original_recoil
    if antiLoop then
        task.cancel(antiLoop)
        antiLoop = nil
    end
    print("‚ùå No Recoil: OFF")
end

function ToggleNoRecoil(state)
    if state then EnableNoRecoil() else DisableNoRecoil() end
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Value = false,
    Callback = function(state)
        ToggleNoRecoil(state)
    end
})

-- Hit Aura
WeaponTab:Section({Title="Auto Hit :"})
getgenv().HitAuraEnabled = false
local autoLoop = nil

local function getActiveTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then return obj end
    end
    return nil
end

local function getPlayersInRange(radius)
    local inRange = {}
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            local CounterTable
            pcall(function()
                for _, Obj in ipairs(getgc(true)) do
                    if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
                        CounterTable = Obj
                        break
                    end
                end
            end)
            local SendRemote
            pcall(function()
                local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
                SendRemote = Remotes:WaitForChild("Send", 5)
            end)
            if CounterTable and SendRemote then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "melee_attack", tool, {target}, lookAtCFrame, 0.75)
                end)
            end
        end
    end
end

local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

function ToggleHitAura(state)
    if state then
        getgenv().HitAuraEnabled = true
        StartHitAura()
        print("‚úÖ Hit Aura: ON")
    else
        StopHitAura()
        print("‚ùå Hit Aura: OFF")
    end
end

WeaponTab:Toggle({
    Title = "Hit Aura",
    Default = false,
    Callback = function(state)
        ToggleHitAura(state)
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Config
local BOX_COLOR = Color3.fromRGB(255, 255, 255)
local BOX_THICKNESS = 2
local SCALE_MULTIPLIER = 1

-- ‡πÄ‡∏Å‡πá‡∏ö ESP ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local espPlayers = {}

-- ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÇ‡∏•‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
local function worldToViewport(pos)
    local screen, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(screen.X, screen.Y), onScreen
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box ESP
local function createBoxESP(plr, getCurrentTarget)
    if espPlayers[plr] or plr == LocalPlayer then return end

    local lines = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = BOX_COLOR
        line.Thickness = BOX_THICKNESS
        line.Transparency = 1
        lines[i] = line
    end

    local connection = RunService.RenderStepped:Connect(function()
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        local root = plr.Character.HumanoidRootPart
        local rootPos = root.Position
        local scale = root.Size.Y * SCALE_MULTIPLIER

        local corners = {
            Vector3.new(-1,  2, -1), Vector3.new( 1,  2, -1), Vector3.new( 1,  2,  1), Vector3.new(-1,  2,  1),
            Vector3.new(-1, -2, -1), Vector3.new( 1, -2, -1), Vector3.new( 1, -2,  1), Vector3.new(-1, -2,  1)
        }

        local screenCorners = {}
        local allOnScreen = true

        for i, offset in ipairs(corners) do
            local worldPos = rootPos + (root.CFrame:VectorToWorldSpace(offset * scale))
            local screenPos, onScreen = worldToViewport(worldPos)
            screenCorners[i] = screenPos
            if not onScreen then allOnScreen = false end
        end

        if not allOnScreen then
            for _, line in ipairs(lines) do line.Visible = false end
            return
        end

        -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏î‡∏á‡∏ñ‡πâ‡∏≤ CurrentTarget ‡πÄ‡∏•‡πá‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ô‡∏µ‡πâ
        local color = (getCurrentTarget() == plr) and Color3.fromRGB(255,0,0) or BOX_COLOR

        local edges = {
            {1,2},{2,3},{3,4},{4,1},
            {5,6},{6,7},{7,8},{8,5},
            {1,5},{2,6},{3,7},{4,8}
        }

        for i, edge in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[edge[1]]
            line.To = screenCorners[edge[2]]
            line.Color = color
            line.Visible = true
        end
    end)

    espPlayers[plr] = {connection = connection, lines = lines}
end

-- ‡∏•‡∏ö Box ESP
local function removeBoxESP(plr)
    if espPlayers[plr] then
        if espPlayers[plr].connection then espPlayers[plr].connection:Disconnect() end
        for _, line in ipairs(espPlayers[plr].lines) do line:Remove() end
        espPlayers[plr] = nil
    end
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function enableAllESP(getCurrentTarget)
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then createBoxESP(plr, getCurrentTarget) end
    end
end

-- ‡∏•‡∏ö ESP ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function disableAllESP()
    for plr, _ in pairs(espPlayers) do
        removeBoxESP(plr)
    end
end

-- Player Added/Removing
Players.PlayerAdded:Connect(function(plr)
    task.wait(1)
    if _G.ESPEnabled then createBoxESP(plr, function() return _G.CurrentTarget end) end
end)
Players.PlayerRemoving:Connect(removeBoxESP)

-- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö Toggle (WindUI)
EspTab:Toggle({
    Title = "Box",
    Icon = "eye",
    Default = false,
    Callback = function(state)
        _G.ESPEnabled = state
        if state then
            enableAllESP(function() return _G.CurrentTarget end)
            print("‚úÖ ESP Box: ON")
        else
            disableAllESP()
            print("‚ùå ESP Box: OFF")
        end
    end
})
